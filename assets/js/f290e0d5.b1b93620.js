(self.webpackChunksmartlink_doc=self.webpackChunksmartlink_doc||[]).push([[3158],{79515:(e,t,r)=>{"use strict";r.r(t),r.d(t,{assets:()=>w,contentTitle:()=>m,default:()=>C,frontMatter:()=>p,metadata:()=>v,toc:()=>b});var s=r(86070),n=r(25710),i=r(99955),a=r(35795),o=r(30758),c=r(33275),l=r(84004),h=r(20757),f=r(29998);function u(e){let{className:t,fingerprint:r}=e;const n=(0,h.D)(r);return r.startsWith("00")?(0,s.jsx)(f.eWW,{className:t}):(0,s.jsx)(h.A,{...n,className:`${t} shrink-0`,shape:"circle",hairColorRandom:!0})}var g=r(65640);const y=e=>{let{profile:t,onData:n,onSuccess:i,onFail:a,state:c}=e,h=(0,o.useRef)();const[f,y]=(0,o.useState)(),[d,p]=(0,o.useState)(!1),[m,v]=(0,o.useState)(!1),[w,b]=(0,o.useState)();let S=!1;return(0,o.useEffect)((()=>(S||(S=!0,(async()=>{const e=t.vaultysId?.toVersion(0);if(!e)return a("no Id");const{PeerjsChannel:s}=r(17598);h.current=new s;const o=h.current?.start();y("https://wallet.vaultys.net#"+h.current?.getConnectionString()+"&protocol=p2p&service=auth&id="+e.id.toString("hex")),o?.then((async()=>{if(!h.current)return p(!0),a("Could not open communication channel");h.current.conn?.on("data",n);try{const e=await(t?.acceptContact(h.current));h.current?.close(),e?(v(!0),b(e.toVersion(1)),i(e.toVersion(1))):(p(!0),a("The handshake has failed!"))}catch(d){p(!0),a("The handshake has failed!")}}))})()),()=>{h.current?.close()})),[c]),(0,o.useEffect)((()=>{g.log(f)}),[f]),d?(0,s.jsx)("div",{}):w?(0,s.jsxs)("div",{className:"rounded-lg shadow-lg p-5 justify-center bg-white dark:bg-slate-900 flex-col flex gap-5 w-64 m-auto font-mono text-sm font-bold",children:[(0,s.jsx)(u,{fingerprint:w.toVersion(1).fingerprint,className:"border border-black border-solid w-24 h-24 m-auto shadow-lg"}),w.toVersion(1).fingerprint]}):f?(0,s.jsx)(l.QrCodeElement,{text:f,className:"rounded-lg shadow-xl"}):void 0},d=()=>{const[e,t]=(0,o.useState)(),[r,n]=(0,o.useState)(),l=(0,o.useRef)([(0,s.jsx)("div",{children:"waiting for connexion through WebRTC..."})]),[h,f]=(0,o.useState)(!1),[u,g]=(0,o.useState)(0);(0,o.useEffect)((()=>{(async()=>{const e=(0,a.DT)("doc_manager");t(await i.IdManager.fromStore(e))})()}));const d={start:()=>(e&&(l.current=[(0,s.jsx)("div",{children:"waiting for connexion through WebRTC..."})]),g(Math.random()),f(!0),l.current),stop:()=>{f(!1),l.current=[(0,s.jsx)("div",{children:"waiting for connexion through WebRTC..."})],g(Math.random())},me:()=>e?.vaultysId.toVersion(1).did,help:(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)("div",{children:"'me' - displays this browser page did"}),(0,s.jsx)("div",{children:"'start' - starts a WebRTC connection"}),(0,s.jsx)("div",{children:"'stop' - stops the WebRTC connection"}),(0,s.jsx)("div",{children:"'contacts' - displays this broaser page Web of Trust contact DIDs"}),(0,s.jsx)("div",{children:"'history' - your contact audit trails"})]}),contacts:()=>e?.contacts.map((e=>(0,s.jsx)("div",{children:e.toVersion(1).did}))),history:()=>e?.listCertificates().map((e=>(0,s.jsxs)("div",{children:[new Date(e.timestamp).toISOString(),": ",e.protocol,"/",e.service]})))},p=(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)("div",{children:"Welcome to the WebRTC test console to interact with the DID of your browser"}),(0,s.jsx)("div",{children:"'help' for all available commands"})]});return(0,s.jsx)(c.XL,{children:(0,s.jsxs)("section",{className:"p-5 flex-col md:flex-row flex gap-2 w-full",children:[(0,s.jsxs)("div",{className:"w-96 h-96 min-h-96 flex flex-col items-center justify-center",children:[h&&e&&(0,s.jsx)(y,{profile:e,onFail:e=>{l.current.push((0,s.jsxs)("div",{className:"text-red-500 font-bold",children:["Error: ",e]})),g(Math.random())},onData:e=>{l.current.push((0,s.jsxs)("div",{className:"break-all",children:["Received: ",e]})),g(Math.random())},onSuccess:t=>{n(t),e?.store.save(),l.current.push((0,s.jsxs)("div",{className:"text-green-500 font-bold",children:["Connected to ",t.did," "]})),g(Math.random())}}),!h&&(0,s.jsxs)("div",{className:"w-full h-full flex flex-col items-center justify-center p-5 bg-opacity-15 bg-black dark:bg-opacity-15 dark:bg-white rounded-lg",children:[" ","Write 'start' in command prompt and get ready with your wallet VaultysID"]})]}),(0,s.jsx)("div",{className:"flex-1 overflow-auto max-h-96",children:(0,s.jsx)(c.e,{theme:"dark",enableInput:!0,showControlBar:!1,commands:d,welcomeMessage:p})},u)]})})},p={hide_table_of_contents:!0},m="WebRTC",v={id:"develop/try/webrtc",title:"WebRTC",description:"",source:"@site/docs/develop/try/webrtc.mdx",sourceDirName:"develop/try",slug:"/develop/try/webrtc",permalink:"/docs/develop/try/webrtc",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{hide_table_of_contents:!0},sidebar:"userguideSidebar",previous:{title:"Simulator",permalink:"/docs/develop/try/simulation"}},w={},b=[];function S(e){const t={h1:"h1",...(0,n.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"webrtc",children:"WebRTC"}),"\n",(0,s.jsx)(d,{})]})}function C(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(S,{...e})}):S(e)}},17598:(e,t,r)=>{"use strict";r.r(t),r.d(t,{PeerjsChannel:()=>l});var s=r(325),n=r(77850),i=r(84686).Buffer,a=r(65640);const{hash:o,randomBytes:c}=n.Et;class l{constructor(e,t,r){void 0===r&&(r="peerjs.92k.de"),this.host=r,this.status=t||(e?"receiver":"initiator"),this.otherstatus="initiator"==this.status?"receiver":"initiator",this.key=e??c(32).toString("hex"),this.id=o("sha256",i.from(`vaultys-${this.status}-${this.key}`)).toString("hex"),this.otherid=n.Et.hash("sha256",i.from(`vaultys-${this.otherstatus}-${this.key}`)).toString("hex");const l={debug:2,host:this.host,secure:!0,logFunction:function(e){for(var t=arguments.length,r=new Array(t>1?t-1:0),s=1;s<t;s++)r[s-1]=arguments[s];return a.log(e.toString(),r)}};if(this.peer=new s.xM(this.id,l),"initiator"==this.status){const e=this;e.peer.on("connection",(t=>{a.log("PeerJs connection incoming..."),e.conn=t,e.conn.on("data",(t=>{a.log("receiving: ",t),e._onData(i.from(t,"base64"))})),e.conn.on("close",(()=>e.peer.destroy())),e._onStarted()}))}n.jC.encryptChannel(this,i.from(this.key,"hex"))}static fromConnectionString(e){if(e.startsWith("vaultys://peerjs?")){const t=new URL(e),r=t.searchParams.get("key"),s=t.searchParams.get("host");return r&&s?new l(r,"receiver",s):null}return null}fromConnectionString(e){return l.fromConnectionString(e)}getConnectionString(){return`vaultys://peerjs?key=${this.key}&host=${this.host}`}async start(){const e=this;return"receiver"===this.status&&(this.conn=this.peer.connect(this.otherid),e.conn.on("open",(t=>{a.log("opening PeerJS Channel..."),e.conn.on("data",(t=>{a.log("receiving: ",t),e._onData(i.from(t,"base64"))})),e.conn.on("close",(()=>e.peer.destroy())),e._onStarted()}))),new Promise((t=>e._onStarted=t))}send(e){a.log("sending: ",e.toString("base64")),this.conn.send(e.toString("base64"))}async receive(){const e=this;return new Promise((t=>e._onData=t))}close(){return this.conn&&this.conn.close(),this.peer.destroy(),Promise.resolve()}}},99955:(e,t,r)=>{"use strict";r.r(t),r.d(t,{Challenger:()=>ne,CryptoChannel:()=>ce.Ay,GameOfLifeIcon:()=>me,IdManager:()=>oe,KeyManager:()=>R,MemoryChannel:()=>he,MemoryStorage:()=>fe.XG,VaultysId:()=>z,crypto:()=>i});var s=r(23069),n=r(54987),i=r(75530),a=r(98408),o=r.n(a),c=r(35848),l=r.n(c),h=r(71899),f=r.n(h),u=r(88965),g=r(58988),y=r(66243),d=r(81840),p=r(10135),m=r(84686).Buffer;const v={},w=1,b=3,S=-1,C=-2,k=-3,K=1,x=2,I={1:g.s9,2:y.sL,3:d.Bt},B={"-257":"SHA-256","-258":"SHA-384","-259":"SHA-512","-65535":"SHA-1","-39":"SHA-512","-38":"SHA-384","-37":"SHA-256","-260":"SHA-256","-261":"SHA-512","-7":"SHA-256","-36":"SHA-512"},E=(e,t)=>(0,i.hash)(e.replace("-",""),t),P=e=>{const t=new p.yI(e),r=t.subject,s=t.issuer,n=t.issuerName.toString(),i=r.split(","),a={};for(const l of i){const e=l.split("=");a[e[0].trim()]=e[1]}const{Version:o}=t.toTextObject().Data,c=t.getExtension(p.WA);return{issuer:s,issuerName:n,subject:a,version:o,basicConstraintsCA:!!c&&c.ca}},D=e=>{const t=e.slice(0,32),r=(e=e.slice(32)).slice(0,1);e=e.slice(1);const s=r[0],n={up:!!(1&s),uv:!!(4&s),at:!!(64&s),ed:!!(128&s),flagsInt:s},i=e.slice(0,4);e=e.slice(4);const a=i.readUInt32BE(0);let o,c,l;if(n.at){o=e.slice(0,16);const t=(e=e.slice(16)).slice(0,2);e=e.slice(2);const r=t.readUInt16BE(0);c=e.slice(0,r),l=e=e.slice(r)}return{rpIdHash:t,flagsBuf:r,flags:n,counter:a,counterBuf:i,aaguid:o,credID:c,COSEPublicKey:l}};const A=(e,t,r)=>g.s9.verify(g.s9.Signature.fromDER(r).toCompactHex(),e,t),M=(e,t,r)=>u.ev.verify(r,e,t);class T{constructor(){this.signCount=0,this.rawId=(0,i.randomBytes)(32),this.aaguid=m.alloc(16)}static createRequest(e){return{publicKey:{challenge:m.from((0,i.randomBytes)(32).toString("base64")),rp:{name:"Vaultys ID",id:"Vaultys ID"},user:{id:"Vaultys Wallet ID",name:"Vaultys Wallet ID",displayName:"Vaultys Wallet ID"},pubKeyCredParams:[{type:"public-key",alg:e}]}}}static getCertificateInfo(e){const t=m.from(e.attestationObject),r=o().decodeAllSync(t)[0];return r.attStmt.x5c?P(r.attStmt.x5c[0]):null}static async create(e,t){let{publicKey:r}=e;void 0===t&&(t="test");const s=new T;if(s.options=r,s.rpId=r.rp.id,s.userHandle=m.from(r.user.id),v[s.rawId.toString("base64")]=s,s.alg=r.pubKeyCredParams[0].alg,-8===s.alg){const e=u.ev.utils.randomPrivateKey();s.keyPair={privateKey:e,publicKey:u.ev.getPublicKey(e)},s.coseKey=new Map,s.coseKey.set(1,1),s.coseKey.set(3,-8),s.coseKey.set(-1,6);const t=s.keyPair.publicKey.slice(0,32);s.coseKey.set(-2,t)}else if(-7===s.alg){const e=g.s9.utils.randomPrivateKey();s.keyPair={privateKey:e,publicKey:g.s9.getPublicKey(e,!1)},s.coseKey=new Map,s.coseKey.set(1,2),s.coseKey.set(3,-7),s.coseKey.set(-1,6);const t=s.keyPair.publicKey.slice(1,33),r=s.keyPair.publicKey.slice(33);s.coseKey.set(-2,t),s.coseKey.set(-3,r)}const n={type:"webauthn.create",challenge:r.challenge,origin:t},a=(0,i.hash)("sha256",m.from(s.rpId,"ascii")),c=m.from("41","hex"),l=m.allocUnsafe(4);l.writeUInt32BE(s.signCount);const h=m.allocUnsafe(2);h.writeUInt16BE(s.rawId.length);const f=o().encode(s.coseKey),y={authData:m.concat([a,c,l,s.aaguid,h,s.rawId,f]),fmt:"none",attStmt:{}};return{id:s.rawId.toString("base64"),rawId:s.rawId,authenticatorAttachment:null,type:"public-key",getClientExtensionResults:()=>({}),response:{clientDataJSON:m.from(JSON.stringify(n),"utf-8"),attestationObject:o().encode(y),getTransports:()=>["usb","hybrid"],getAuthenticatorData:()=>y.authData,getPublicKey:()=>f,getPublicKeyAlgorithm:()=>-7}}}static simpleVerify(e,t,r){void 0===r&&(r=!1);const s=o().decode(e),n=(t.authenticatorData.slice(0,32),m.from(t.authenticatorData)[32]);t.authenticatorData.slice(33,37);if(!(r?!!(4&n):!!(1&n)))return!1;const a=(0,i.hash)("sha256",m.from(t.clientDataJSON));let c=m.concat([m.from(t.authenticatorData),a]);if(-7==s.get(3)&&(c=(0,i.hash)("sha256",c)),1==s.get(1)){const e=s.get(-2);return M(c,e,m.from(t.signature))}if(2==s.get(1)){const e=s.get(-2),r=s.get(-3),n=m.concat([m.from("04","hex"),e,r]);return A(c,n,m.from(t.signature))}return!1}static getCOSEPublicKey(e){const t=e.response,r=o().decode(t.attestationObject);return D(r.authData).COSEPublicKey}static verifyPackedAttestation(e,t){return void 0===t&&(t=!1),async function(e,t){void 0===t&&(t=!1);const r=m.from(e.attestationObject),s=o().decodeAllSync(r)[0];if("none"==s.fmt)return!1;const n=D(s.authData);if(!n.flags.up)return!1;if(t&&!n.flags.uv)return!1;const i=E("sha256",m.from(e.clientDataJSON)),a=m.concat([s.authData,i]),c=s.attStmt.sig;let l=!1;if(s.attStmt.x5c){const e=(e=>{let t="";for(let r=0;r<e.length;r+=64)t+=e.slice(r,r+64)+"\n";return"-----BEGIN CERTIFICATE-----\n"+t+"-----END CERTIFICATE-----"})(s.attStmt.x5c[0].toString("base64")),t=P(s.attStmt.x5c[0]),r=t.subject;if("Authenticator Attestation"!==r.OU)throw new Error('Batch certificate OU MUST be set strictly to "Authenticator Attestation"!');if(!r.CN)throw new Error("Batch certificate CN MUST no be empty!");if(!r.O)throw new Error("Batch certificate O MUST no be empty!");if(!r.C||2!==r.C.length)throw new Error("Batch certificate C MUST be set to two character ISO 3166 code!");if(t.basicConstraintsCA)throw new Error("Batch certificate basic constraints CA MUST be false!");if("v3 (2)"!==t.version)throw new Error("Batch certificate version MUST be 3(ASN1 2)!");l=f().createVerify("sha256").update(a).verify(e,c)}else{if(s.attStmt.ecdaaKeyId)throw new Error("ECDAA IS NOT SUPPORTED!");{const e=o().decodeAllSync(n.COSEPublicKey)[0],t=B[e.get(b)],r=E(t,a);if(e.get(w)===x){const t=e.get(C),s=e.get(k),n=m.concat([m.from([4]),t,s]),i=I[e.get(S)],a=i.Signature.fromDER(c);l=i.verify(a,r,n)}else{if(e.get(w)!==K)return!1;{const t=e.get(C);l=u.ev.verify(c,r,t)}}}}if(!l)throw new Error("Failed to verify the signature!");return!0}(e,t)}static verify(e,t,r){void 0===r&&(r=!1);const s=(0,i.hash)("sha256",m.from(t.response.clientDataJSON)),n=t.response,a=e.response;let c=m.concat([m.from(n.authenticatorData),s]);const l=o().decode(a.attestationObject),h=D(l.authData);if(!h.flags.up)return!1;if(r&&!h.flags.uv||!h.COSEPublicKey)return!1;const f=o().decode(h.COSEPublicKey);if(-7==f.get(3)&&(c=(0,i.hash)("sha256",c)),1==f.get(1)){const e=f.get(-2);return M(c,e,m.from(n.signature))}if(2==f.get(1)){const e=f.get(-2),t=f.get(-3),r=m.concat([m.from("04","hex"),e,t]);return A(c,r,m.from(n.signature))}}static extractChallenge(e){const t=JSON.parse(e.toString()),r=t.challenge.length%4;return t.challenge.replace(/-/g,"+").replace(/_/g,"/").padEnd(t.challenge.length+(0===r?0:4-r),"=")}static async get(e,t){let{publicKey:r}=e;if(void 0===t&&(t="test"),!r.allowCredentials)throw new Error;const s=m.from(r.allowCredentials[0].id).toString("base64");let n=v[s];n.signCount+=1;const a={type:"webauthn.get",challenge:m.from(r.challenge).toString("base64"),origin:t},o=(0,i.hash)("sha256",(0,i.fromUTF8)(JSON.stringify(a))),c=(0,i.hash)("sha256",m.from(n.rpId,"utf-8")),l=m.from("05","hex"),h=m.allocUnsafe(4);h.writeUInt32BE(n.signCount);const f=m.concat([c,l,h]);let y=m.concat([f,o]),d=new Uint8Array;-7===n.alg?d=g.s9.sign(y,n.keyPair.privateKey,{prehash:!0}).toDERRawBytes():-8===n.alg&&(d=u.ev.sign(y,n.keyPair.privateKey));return{id:s,rawId:m.from(s,"base64"),type:"public-key",authenticatorAttachment:null,getClientExtensionResults:()=>({}),response:{authenticatorData:f,clientDataJSON:m.from(JSON.stringify(a),"utf-8"),signature:d,userHandle:n.userHandle}}}}var j=r(34919),O=r(41408),_=r(817);const N=(e,t)=>{let r=e;return t.startsWith("m/")&&(t=t.slice(2)),t.split("/").forEach((e=>{r="'"==e[e.length-1]?r.derive(2147483648+parseInt(e.substring(0,e.length-1))):r.derive(parseInt(e))})),r};class R{level=1;version=1;capability="private";constructor(){this.authType="Ed25519VerificationKey2020",this.encType="X25519KeyAgreementKey2019"}static async create_Id25519_fromEntropy(e,t){void 0===t&&(t=0);const r=new R;r.entropy=e,r.level=1,r.capability="private";const s=(n=e,(0,i.hash)("sha512",n));var n;const a=N(await _.Bip32PrivateKey.fromEntropy(s.slice(0,32)),`m/1'/0'/${t}'`);r.proofKey={publicKey:a.toBip32PublicKey().toPublicKey().toBytes(),secretKey:a.toBytes()},r.swapIndex=t,r.proof=(0,i.hash)("sha256",r.proofKey.publicKey);const o=N(a,"/0'");r.signer={publicKey:o.toBip32PublicKey().toPublicKey().toBytes(),secretKey:o.toBytes()};const c=O.Buffer.alloc(8);c.writeBigInt64LE(BigInt(t));const h=(e=>(0,i.hash)("sha256",e))(O.Buffer.concat([s.slice(32,64),c])),f=l().box.keyPair.fromSecretKey(h);return r.cypher={publicKey:O.Buffer.from(f.publicKey),secretKey:O.Buffer.from(f.secretKey)},r}static generate_Id25519(){return R.create_Id25519_fromEntropy((0,i.randomBytes)(32))}get id(){return 0==this.version?(e=>{const t=O.Buffer.from([132,161,118,0]),r=O.Buffer.from([161,112,197,0,e.proof.length,...e.proof]),s=O.Buffer.from([161,120,197,0,e.signer.publicKey.length,...e.signer.publicKey]),n=O.Buffer.from([161,101,197,0,e.cypher.publicKey.length,...e.cypher.publicKey]);return O.Buffer.concat([t,r,s,n])})(this):O.Buffer.from((0,n.l)({v:this.version,p:this.proof,x:this.signer.publicKey,e:this.cypher.publicKey}))}getSecret(){return O.Buffer.from((0,n.l)({v:this.version,p:this.proof,x:this.signer.secretKey,e:this.cypher.secretKey}))}static fromSecret(e){const t=(0,s.D4)(e),r=new R;r.version=t.v,r.level=2,r.capability="private",r.proof=t.p,r.signer={secretKey:t.x,publicKey:new _.Bip32PrivateKey(t.x).toBip32PublicKey().toPublicKey().toBytes()};const n=l().box.keyPair.fromSecretKey(t.e);return r.cypher={publicKey:O.Buffer.from(n.publicKey),secretKey:O.Buffer.from(n.secretKey)},r}static instantiate(e){const t=new R;return t.version=e.version??0,t.level=e.level,t.proof=e.proof.data?O.Buffer.from(e.proof.data):O.Buffer.from(e.proof),t.signer={publicKey:e.signer.publicKey.data?O.Buffer.from(e.signer.publicKey.data):O.Buffer.from(e.signer.publicKey)},t.cypher={publicKey:e.cypher.publicKey.data?O.Buffer.from(e.cypher.publicKey.data):O.Buffer.from(e.cypher.publicKey)},t}static fromId(e){const t=(0,s.D4)(e),r=new R;return r.version=t.v,r.level=2,r.capability="public",r.proof=t.p,r.signer={publicKey:t.x},r.cypher={publicKey:t.e},r}async sign(e){return"public"==this.capability?null:new _.Bip32PrivateKey(this.signer.secretKey).toPrivateKey().sign(e)}verify(e,t,r){return _.Bip32PublicKey.fromBytes(this.signer.publicKey).toPublicKey().verify(t,e)}async createSwapingCertificate(){if(1===this.level){const e={newId:(await R.create_Id25519_fromEntropy(this.entropy,this.swapIndex+1)).id,proofKey:this.proofKey.publicKey,timestamp:Date.now(),signature:O.Buffer.from([])},t=O.Buffer.alloc(8);t.writeBigUInt64LE(BigInt(e.timestamp));const r=O.Buffer.concat([e.newId,e.proofKey,t]);return e.signature=new _.Bip32PrivateKey(this.proofKey.secretKey).toPrivateKey().sign(r),e}return null}async verifySwapingCertificate(e){if((0,i.hash)("sha256",e.proofKey).toString("hex")===this.proof.toString("hex")){const t=O.Buffer.alloc(8);t.writeBigUInt64LE(BigInt(e.timestamp));R.fromId(e.newId);const r=O.Buffer.concat([e.newId,e.proofKey,t]);return _.Bip32PublicKey.fromBytes(e.proofKey).toPublicKey().verify(r,e.signature)}return!1}async encrypt(e,t){if("private"==this.capability){const r=t.map(R.fromId).map((e=>e.cypher.publicKey));return await(0,j.MO)(e,this.cypher,r)}return null}async decrypt(e,t){if(void 0===t&&(t=null),"public"==this.capability)return null;const r=t?R.fromId(t).cypher.publicKey:null;return(await(0,j.P_)(e,this.cypher,r)).toString()}getSecretHash(e){const t=O.Buffer.concat([e,O.Buffer.from("secrethash"),this.cypher.secretKey]);return(0,i.hash)("sha256",t)}}var U=r(84686).Buffer;const V={usb:1,nfc:2,ble:4,internal:8,hybrid:16,"smart-card":32},H=e=>{const t=U.from([131,161,118,e.version]),r=U.concat([U.from([161,99,197,0,e.ckey.length]),e.ckey]),s=U.concat([U.from([161,101,197,0,e.cypher.publicKey.length]),e.cypher.publicKey]);return U.concat([t,r,s])},W=e=>Object.keys(V).filter((t=>e&&V[t])),F=e=>{const t=o().decode(e).get(1);return 1===t?"Ed25519VerificationKey2020":2===t?"P256VerificationKey2020":"Unknown"},$=e=>{const t=o().decode(e);let r=U.from([]);return-7==t.get(3)?r=U.concat([U.from("04","hex"),t.get(-2),t.get(-3)]):-8==t.get(3)&&(r=t.get(-2)),{publicKey:r}};class J extends R{_transports=0;constructor(){super(),this.level=1,this.encType="X25519KeyAgreementKey2019"}get transports(){return W(this._transports)}static async createFromAttestation(e){const t=new J;t.ckey=T.getCOSEPublicKey(e),t.authType=F(t.ckey),t.fid=U.from(e.id,"base64");const r=e.response,s=r.getTransports?r.getTransports():["usb"];t._transports=(e=>e.reduceRight(((e,t)=>e+(V[t]?V[t]:0)),0))(s),t.signer=$(t.ckey);const n=(0,i.randomBytes)(32),a=(o=n,(0,i.hash)("sha512",o));var o;const c=l().box.keyPair.fromSecretKey(a.slice(0,32));return t.cypher={publicKey:U.from(c.publicKey),secretKey:U.from(c.secretKey)},t.entropy=n,t}get id(){return 0==this.version?H(this):U.from((0,n.l)({v:this.version,c:this.ckey,e:this.cypher.publicKey}))}get id_v0(){return H(this)}getSecret(){return U.from((0,n.l)({v:this.version,f:this.fid,t:this._transports,c:this.ckey,e:this.cypher.secretKey}))}static fromSecret(e){const t=(0,s.D4)(e),r=new J;r.version=t.v,r.capability="private",r.fid=t.f,r._transports=t.t?t.t:15,r.ckey=t.c,r.authType=F(r.ckey),r.signer=$(t.c);const n=l().box.keyPair.fromSecretKey(t.e);return r.cypher={publicKey:U.from(n.publicKey),secretKey:U.from(n.secretKey)},r}static instantiate(e){const t=new J;return t.version=e.version??0,t.level=e.level,t.fid=e.fid,t._transports=e.t?e.t:15,t.ckey=e.ckey.data?U.from(e.ckey.data):U.from(e.ckey),t.signer=$(t.ckey),t.authType=F(t.ckey),t.cypher={publicKey:e.cypher.publicKey.data?U.from(e.cypher.publicKey.data):U.from(e.cypher.publicKey)},t}static fromId(e){const t=(0,s.D4)(e),r=new J;return r.version=t.v,r.capability="public",r.fid=t.f,r.ckey=t.c,r.signer=$(t.c),r.authType=F(r.ckey),r.cypher={publicKey:t.e},r}async sign(e){if("public"==this.capability)return null;if(!navigator.credentials)return null;try{await(window?.CredentialUserInteractionRequest())}catch(o){}const t={challenge:(0,i.hash)("sha256",e),userVerification:"preferred",allowCredentials:[{type:"public-key",id:this.fid,transports:W(this._transports)}]},{response:r}=await navigator.credentials.get({publicKey:t}),s=r,a={s:U.from(s.signature),c:U.from(s.clientDataJSON),a:U.from(s.authenticatorData)};return U.from((0,n.l)(a))}verify(e,t,r){const n=(0,s.D4)(t),a={signature:n.s,clientDataJSON:n.c,authenticatorData:n.a,userHandle:U.from([])};return(0,i.hash)("sha256",e).toString("base64")==T.extractChallenge(a.clientDataJSON)&&T.simpleVerify(this.ckey,a,r)}verifyCredentials(e,t){if(void 0===t&&(t=!1),e.id!==this.fid.toString("base64"))return!1;const r=e.response;var s;return U.from(r.authenticatorData.slice(0,32)).toString("hex")===(s=U.from(e.id,"base64"),(0,i.hash)("sha256",s)).toString("hex")&&T.simpleVerify(this.ckey,r,t)}async createRevocationCertificate(e){return null}}var L=r(84686).Buffer;class z{constructor(e,t,r){void 0===r&&(r=0),this.type=r,this.keyManager=e,this.certificate=t}static fromId(e,t,r){void 0===r&&(r="hex");let s=e;e.data&&(s=L.from(e.data)),e instanceof Uint8Array&&(s=L.from(e)),"string"==typeof e&&(s=L.from(e,r));const n=s[0];if(3==n){const e=J.fromId(s.slice(1));return new z(e,t,n)}{const e=R.fromId(s.slice(1));return new z(e,t,n)}}static async fromEntropy(e,t){const r=e,s=await R.create_Id25519_fromEntropy(r);return new z(s,void 0,t)}static async fido2FromAttestation(e){await T.verifyPackedAttestation(e.response,!0);const t=await J.createFromAttestation(e);return new z(t,void 0,3)}static async machineFromEntropy(e){return z.fromEntropy(e,0)}static async organizationFromEntropy(e){return z.fromEntropy(e,2)}static async personFromEntropy(e){return z.fromEntropy(e,1)}static fromSecret(e,t){void 0===t&&(t="hex");const r=L.from(e,t),s=r[0];if(3==s){const e=J.fromSecret(r.slice(1));return new z(e,void 0,s)}{const e=R.fromSecret(r.slice(1));return new z(e,void 0,s)}}static async generatePerson(){const e=await R.generate_Id25519();return new z(e,void 0,1)}static async generateOrganization(){const e=await R.generate_Id25519();return new z(e,void 0,2)}static async generateMachine(){const e=await R.generate_Id25519();return new z(e,void 0,0)}get relationshipCertificate(){return this.certificate}getSecret(e){return void 0===e&&(e="hex"),L.concat([L.from([this.type]),this.keyManager.getSecret()]).toString(e)}get fingerprint(){return(L.from([this.type]).toString("hex")+(0,i.hash)("SHA224",this.keyManager.id).toString("hex")).slice(0,40).toUpperCase().match(/.{1,4}/g).join(" ")}get did(){return`did:vaultys:${(L.from([this.type]).toString("hex")+(0,i.hash)("SHA224",this.keyManager.id).toString("hex")).slice(0,40)}`}get didDocument(){return{"@context":["https://www.w3.org/ns/did/v1","https://w3id.org/security/suites/ed25519-2020/v1"],id:this.did,authentication:[{id:`${this.did}#keys-1`,type:this.keyManager.authType,controller:this.did,publicKeyMultibase:"m"+this.keyManager.signer.publicKey.toString("base64")}],keyAgreement:[{id:`${this.did}#keys-2`,type:this.keyManager.encType,controller:this.did,publicKeyMultibase:"m"+this.keyManager.cypher.publicKey.toString("base64")}]}}get id(){return L.concat([L.from([this.type]),this.keyManager.id])}toVersion(e){return this.keyManager.version=e,this}get version(){return this.keyManager.version}isHardware(){return 3===this.type}isMachine(){return 0===this.type}isPerson(){return 1===this.type}getOTPHmac(e){void 0===e&&(e=36e5);const t=Math.floor((new Date).getTime()/e);return this.keyManager.getSecretHash(L.from(`OTP-${t}`)).toString("hex")}getOTP(e,t){if(void 0===e&&(e="password"),void 0===t&&(t=864e5),this.certificate){const r=Math.floor((new Date).getTime()/t),s=L.concat([L.from(e,"utf-8"),L.from(this.certificate),L.from([r])]);return(0,i.hash)("SHA256",s).toString("hex")}throw new Error("no certificate, cannot derive OTP")}async signChallenge(e){"string"==typeof e&&(e=L.from(e,"hex"));const t=(0,i.hash)("sha256",L.concat([this.id,e]));return this.keyManager.sign(t)}verifyChallenge(e,t,r){"string"==typeof e&&(e=L.from(e,"hex")),"string"==typeof t&&(t=L.from(t,"hex"));const s=(0,i.hash)("sha256",L.concat([this.id,e]));return this.keyManager.verify(s,t,r)}async encrypt(e,t){return this.keyManager.encrypt(e,t.map((e=>"string"==typeof e?L.from(e.slice(2),"hex"):e.slice(1))))}async decrypt(e,t){let r;return t&&(r="string"==typeof t?L.from(t.slice(2)):t.subarray(1)),this.keyManager.decrypt(e,r)}}var G=r(84686).Buffer,X=r(65640);const q=-2,Z=(e,t)=>G.concat([G.from([160+e.length]),G.from(e,"ascii"),G.from([160+t.length]),G.from(t,"ascii")]),Q=(e,t)=>G.concat([G.from([160+e.length]),G.from(e,"ascii"),G.from([197,t.length>>8,t.length]),t]),Y=(e,t)=>{const r=G.concat([G.from([160+e.length]),G.from(e,"ascii")]);let s;if(t>=0&&t<=127)s=G.from([t]);else if(t<0&&t>=-32)s=G.from([t]);else if(t>0&&t<=255)s=G.from([204,t]);else if(t>=-128&&t<=127)s=G.from([208,t]);else if(t>0&&t<=65535)s=G.from([205,t>>>8,t]);else if(t>=-32768&&t<=32767)s=G.from([209,t>>>8,t]);else if(t>0&&t<=4294967295)s=G.from([206,t>>>24,t>>>16,t>>>8,t]);else if(t>=-2147483648&&t<=2147483647)s=G.from([210,t>>>24,t>>>16,t>>>8,t]);else if(t>0&&t<=0x10000000000000000){let e=t/2**32,r=t%2**32;s=G.from([211,e>>>24,e>>>16,e>>>8,e,r>>>24,r>>>16,r>>>8,r])}else s=G.from([0]);return G.concat([r,s])},ee=e=>{let{protocol:t,service:r,timestamp:s,pk1:n,pk2:i,nonce:a,sign1:o,sign2:c,metadata:l}=e;return G.concat([G.from([137]),Z("protocol",t),Z("service",r),Y("timestamp",s),Q("pk1",n),Q("pk2",i),Q("nonce",a),Q("sign1",o),Q("sign2",c),G.from([168]),G.from("metadata","ascii"),G.from([128])])},te=e=>{const t={...(0,s.D4)(e),...{state:q,error:""}};try{if(!t.pk2&&!t.sign1&&!t.sign2&&16==t.nonce?.length&&t.pk1?.length&&t.pk1.length>0)t.state=0;else if(!t.sign1&&32==t.nonce?.length&&t.pk1?.length&&t.pk2?.length&&t.sign2?.length&&t.pk1.length>0&&t.pk2.length>0&&t.sign2.length>0){const e=z.fromId(t.pk2),r=re(t,e.version);e.verifyChallenge(r,t.sign2,!0)?t.state=1:(t.state=q,t.error="STEP1 failed to verification of pk2")}else if(t.sign1?.length&&t.sign1.length>0&&32==t.nonce?.length&&t.pk1?.length&&t.pk2?.length&&t.sign2?.length&&t.pk1.length>0&&t.pk2.length>0&&t.sign2.length>0){const e=z.fromId(t.pk1),r=z.fromId(t.pk2);if(e.version!=r.version)t.state=q,t.error="pk1 and pk2 are using different serialization version, this is not allowed";else{const s=re(t,e.version);r.verifyChallenge(s,t.sign2,!0)?e.verifyChallenge(s,t.sign1,!0)?t.state=2:(t.state=q,t.error="challenge failed to verification of pk1"):(t.state=q,t.error="challenge failed to verification of pk2, looks like a tentative to tamper with an existing signature")}}}catch(r){t.state=q,t.error=r}return t},re=function(e,t){void 0===t&&(t=0);const{protocol:r,service:s,timestamp:i,pk1:a,pk2:o,nonce:c,metadata:l}=e,h={protocol:r,service:s,timestamp:i,pk1:a,pk2:o,nonce:c,metadata:l};return 0===t?(e=>{let{protocol:t,service:r,timestamp:s,pk1:n,pk2:i,nonce:a,metadata:o}=e;return G.concat([G.from([135]),Z("protocol",t),Z("service",r),Y("timestamp",s),Q("pk1",n),Q("pk2",i),Q("nonce",a),G.from([168]),G.from("metadata","ascii"),G.from([128])])})(h):G.from((0,n.l)(h))},se=(e,t)=>{const r=Date.now();return r-e.timestamp<t&&e.timestamp<=r+1e4};class ne{constructor(e,t){void 0===t&&(t=6e4),this.state=-1,this.vaultysId=e,this.liveliness=t}static async verifyCertificate(e){return 2==te(e).state}static deserializeCertificate=te;static serializeCertificate_v0=ee;static serializeCertificate=re;async setChallenge(e){if(-1!==this.state)throw new Error("Challenger already initialised, can't reset the state");if(this.challenge=te(e),!se(this.challenge,this.liveliness))throw this.state=q,this.challenge.error="challenge timestamp failed the liveliness at first signature",new Error(this.challenge.error);if(this.challenge.state==q)throw this.state=q,X.error(this.challenge),new Error(this.challenge.error);if(0==this.challenge.state){this.challenge.protocol,this.challenge.service;this.mykey=this.vaultysId.id,this.challenge.pk2=this.mykey,this.hisKey=this.challenge.pk1,this.challenge.nonce=G.concat([this.challenge.nonce||new Uint8Array,(0,i.randomBytes)(16)]);const e=this.getUnsignedChallenge();if(!e)throw new Error("Error processing Challenge");this.challenge.sign2=await this.vaultysId.signChallenge(e)||void 0,this.challenge.state=this.state=1}else{if(2!=this.challenge.state)throw new Error("Challenge is from a protocol already launched, this is completely unsafe");if(this.challenge.pk1!=this.mykey&&this.challenge.pk2!=this.mykey)throw this.state=q,new Error("Can't link the vaultys id to this challenge");this.state=2}}getContext(){return{protocol:this.challenge?.protocol,service:this.challenge?.service,metadata:this.challenge?.metadata}}createChallenge(e,t,r,s){if(void 0===r&&(r=1),void 0===s&&(s={}),-1!=this.state)throw this.state=q,new Error("Challenger already initialised, can't reset the state");this.mykey=this.vaultysId.toVersion(r).id,this.challenge={protocol:e,service:t,metadata:s,timestamp:Date.now(),pk1:this.mykey,nonce:(0,i.randomBytes)(16),state:0},this.state=0}getCertificate(){return this.challenge?G.from((e=>{if(0==e.state){const{protocol:t,service:r,timestamp:s,pk1:i,nonce:a,metadata:o}=e,c={protocol:t,service:r,timestamp:s,pk1:i,nonce:a,metadata:o},l=(0,n.l)(c);return G.from(l)}if(1==e.state){const{protocol:t,service:r,timestamp:s,pk1:i,pk2:a,nonce:o,sign2:c,metadata:l}=e,h={protocol:t,service:r,timestamp:s,pk1:i,pk2:a,nonce:o,sign2:c,metadata:l},f=(0,n.l)(h);return G.from(f)}if(2==e.state){const{protocol:t,service:r,timestamp:s,pk1:i,pk2:a,nonce:o,sign1:c,sign2:l,metadata:h}=e,f={protocol:t,service:r,timestamp:s,pk1:i,pk2:a,nonce:o,sign1:c,sign2:l,metadata:h},u=(0,n.l)(f);return G.from(u)}return null})(this.challenge)||[]):null}getUnsignedChallenge(){return re(this.challenge,this.vaultysId.version)}getContactDid(){return this.hisKey?z.fromId(this.hisKey).did:null}getContactId(){if(this.isComplete()){return z.fromId(this.hisKey,this.getCertificate()||void 0)}throw new Error("The challenge is not COMPLETE, it is unsafe to get the Contact ID before")}static fromString(e,t){const r=new ne(e);return r.setChallenge(t),r}hasFailed(){return this.state==q}isComplete(){return 2==this.state}isSelfAuth(){return this.mykey?.toString("hex")==this.hisKey?.toString("hex")}async update(e,t){if(void 0===t&&(t={}),-1==this.state)await this.setChallenge(e);else if(0==this.state){if(this.challenge=te(e),!se(this.challenge,this.liveliness))throw this.state=q,this.challenge.error="challenge timestamp failed the liveliness at 2nd signature",new Error(this.challenge.error);if(1!=this.challenge.state)throw this.state=q,new Error(`The challenge is in an expected state. Received state = '${this.challenge.state}', expected state = '1'`);{if(this.state=1,!this.mykey||!this.challenge.pk1||0!=G.compare(this.mykey,this.challenge.pk1))throw new Error(`The challenge has been tampered with. Received pk1 = '${this.challenge.pk1}', expected pk1 = '${this.mykey}'`);this.hisKey=this.challenge.pk2;const e=this.getUnsignedChallenge();if(!e)throw new Error("Error processing Challenge");this.challenge.sign1=await this.vaultysId.signChallenge(e)||void 0,this.state=this.challenge.state=2}}else{if(1!=this.state)throw this.state=q,new Error;if(this.challenge=te(e),this.mykey=this.challenge.pk2,2!=this.challenge.state)throw this.state=q,new Error(`The challenge is in an expected state. Received state = '${this.challenge.state}', expected state = '2'`);this.state=2}}}var ie=r(84686).Buffer;const ae=e=>e.startsWith("vaultys://login?")?"LOGIN":e.startsWith("vaultys://docsign?")?"DOCUMENT":"UNKNOWN";class oe{constructor(e,t){this.vaultysId=e,this.store=t,this.store.get("metadata")||this.store.set("metadata",{}),this.vaultysId.keyManager.entropy?this.store.set("entropy",this.vaultysId.keyManager.entropy):this.store.set("secret",this.vaultysId.getSecret()),this.store.save()}static async fromStore(e){const t=e.get("entropy"),r=e.get("secret");if(r){if(t){const s=ie.from(r,"base64")[0],n=await z.fromEntropy(t,s);return new oe(n,e)}{const t=z.fromSecret(r);return new oe(t,e)}}if(t){const r=await z.machineFromEntropy(t);return new oe(r,e)}{const t=await z.generateMachine();return new oe(t,e)}}merge(e,t){void 0===t&&(t=!0);const r=t?e:this.store,s=t?this.store:e;this.store.set("metadata",{...s.get("metadata"),...r.get("metadata")}),["signatures","wot"].forEach((t=>{let r=e.substore(t),s=this.store.substore(t);r.list().forEach((e=>{s.get(e)||s.set(e,r.get(e))}))}));let n=e.substore("contacts"),i=this.store.substore("contacts");const a=t?n:i,o=t?i:n;n.list().forEach((e=>{if(i.get(e)){const t=i.get(e);t.metadata={...o.get(e).metadata,...a.get(e).metadata},i.set(e,t)}else i.set(e,n.get(e))})),this.store.save()}isHardware(){return this.vaultysId.isHardware()}async signIn(){if(!this.vaultysId.isHardware())return!0;await window.CredentialUserInteractionRequest();const e=(0,i.randomBytes)(32),t=this.vaultysId.keyManager,r=await navigator.credentials.get({publicKey:{challenge:e,allowCredentials:[{type:"public-key",id:t.fid,transports:t.transports}],userVerification:"discouraged"}});if(null==r)return!1;const s=r.response,n=T.extractChallenge(ie.from(s.clientDataJSON));return e.toString("base64")===n&&t.verifyCredentials(r)}get contacts(){const e=this.store.substore("contacts");return e.list().map((t=>e.get(t))).map((e=>3===e.type?new z(J.instantiate(e.keyManager),e.certificate,e.type):new z(R.instantiate(e.keyManager),e.certificate,e.type)))}getContact(e){const t=this.store.substore("contacts").get(e);return t?3===t.type?new z(J.instantiate(t.keyManager),t.certificate,t.type):new z(R.instantiate(t.keyManager),t.certificate,t.type):null}setContactMetadata(e,t,r){const s=this.store.substore("contacts").get(e);s&&(s.metadata||(s.metadata={}),s.metadata[t]=r)}getContactMetadata(e,t){const r=this.store.substore("contacts").get(e);return r&&r.metadata?r.metadata[t]:null}getContactMetadatas(e){const t=this.store.substore("contacts").get(e);return t&&t.metadata?t.metadata:null}async verifyRelationshipCertificate(e){const t=this.store.substore("contacts").get(e)||this.store.substore("registrations").get(e);return ne.verifyCertificate(t.certificate)}set name(e){this.store.get("metadata").name=e}get name(){return this.store.get("metadata").name}get displayName(){const e=this.store.get("metadata");return e.firstname?e.firstname+" "+(e.name??""):e.name??"Anonymous "+this.vaultysId.fingerprint?.slice(-4)}set phone(e){this.store.get("metadata").phone=e}get phone(){return this.store.get("metadata").phone}set email(e){this.store.get("metadata").email=e}get email(){return this.store.get("metadata").email}async signChallenge(e){const t=await this.vaultysId.signChallenge(e);return this.store.substore("signatures").set(""+Date.now(),{signature:t,challenge:e}),this.store.save(),t}async signFile(e){const t=ie.from(`vaultys://docsign?hash=${e.toString("hex")}&timestamp=${Date.now()}`,"utf-8"),r={challenge:t,signature:await this.vaultysId.signChallenge(t)};return this.store.substore("signatures").set(Date.now()+"",r),this.store.save(),r}async verifyFile(e,t,r){void 0===r&&(r=!0);const s=e.toString("utf8");if(!s.startsWith("vaultys://docsign?"))return!1;const n=new URL(s);return!(2!==n.search.match(/[a-z\d]+=[a-z\d]+/gi)?.length||!n.searchParams.get("hash")||!n.searchParams.get("timestamp"))&&await this.vaultysId.verifyChallenge(e,t,r)}getSignatures(){const e=this.store.substore("signatures");return e.list().sort().map((t=>{const r=e.get(t),s=ie.from(r.challenge).toString("utf-8");return{date:t,payload:r,challenge:s,type:ae(s)}}))}migrate(e){if(e!=this.vaultysId.version){const t=this.store.substore("contacts");for(const r of t.list()){const s=this.getContact(r);if(s){const n=s?.toVersion(e);t.set(n.did,{...s,...n}),t.delete(r)}}}}async verifyChallenge(e,t){return this.vaultysId.verifyChallenge(e,t,!0)}async sync(e,t){if(void 0===t&&(t=!1),t){const r=await this.startSRP(e,"p2p","selfauth");if(r.isSelfAuth()&&r.isComplete()){const r=this.store.fromString((await e.receive()).toString("utf-8"));e.send(ie.from(this.store.toString(),"utf-8")),this.merge(r,!t)}}else{const r=await this.acceptSRP(e,"p2p","selfauth",!0);if(r.isSelfAuth()&&r.isComplete()){e.send(ie.from(this.store.toString(),"utf-8"));const r=this.store.fromString((await e.receive()).toString("utf-8"));this.merge(r,!t)}e.close()}this.store.save()}listCertificates(){const e=this.store.substore("wot");return e.list().map((t=>{const r=e.get(t);if(r.timestamp)return r;{const s={...ne.deserializeCertificate(e.get(t)),raw:r};return e.set(t,s),s}}))}async startSRP(e,t,r){const s=new ne(this.vaultysId.toVersion(0));s.createChallenge(t,r,0);const n=s.getCertificate();if(!n)throw e.close(),e.send(ie.from([0])),new Error("Error processing challenge");e.send(n);try{const t=await e.receive();await s.update(t)}catch(i){throw e.send(ie.from([0])),new Error(i)}if(s.isComplete()){const t=s.getCertificate();if(!t)throw e.close(),e.send(ie.from([0])),new Error("Error processing challenge");return e.send(t),this.store.substore("wot").set(Date.now()+"",t),s}throw e.send(ie.from([0])),new Error("Can't add a new contact if the protocol is not complete")}async acceptSRP(e,t,r,s){void 0===s&&(s=!1);const n=new ne(this.vaultysId.toVersion(0));try{let t=await e.receive();await n.update(t)}catch(o){throw e.send(ie.from([0])),new Error(o)}const i=n.getContext();if(i.protocol!=t||i.service!=r)throw e.send(ie.from([0])),new Error(`The challenge was expecting protocol '${t}' and service '${r}', received '${i.protocol}' and '${i.service}'`);const a=n.getCertificate();if(!a)throw e.close(),e.send(ie.from([0])),new Error("Error processing challenge");e.send(a);try{let t=await e.receive();await n.update(t)}catch(o){throw e.close(),new Error(o)}if(n.isComplete()){const t=n.getCertificate();return s||e.close(),this.store.substore("wot").set(Date.now()+"",t),n}throw e.close(),new Error("Can't add a new contact if the protocol is not complete")}saveContact(e){e.toVersion(this.vaultysId.version),e.isMachine()?this.store.substore("registrations").set(e.did,{site:e.did,serverId:e?.id.toString("base64"),certificate:e.certificate}):this.store.substore("contacts").set(e.did,e),this.store.save()}async askContact(e){const t=(await this.startSRP(e,"p2p","auth")).getContactId();return this.saveContact(t),t}async acceptContact(e){const t=(await this.acceptSRP(e,"p2p","auth")).getContactId();return this.saveContact(t),t}async askMyself(e){const t=await this.startSRP(e,"p2p","selfauth");return t.isSelfAuth()&&t.isComplete()}async acceptMyself(e){const t=await this.acceptSRP(e,"p2p","selfauth");return t.isSelfAuth()&&t.isComplete()}}var ce=r(3459);const le=e=>new Promise((t=>setTimeout(t,e)));class he{setChannel(e,t){this.name=t,this.otherend=e}static createBidirectionnal(){const e=new he,t=new he;return e.setChannel(t),t.setChannel(e),e}static createEncryptedBidirectionnal(e){e=e||ce.Ay.generateKey();const t=ce.Ay.encryptChannel(new he,e),r=ce.Ay.encryptChannel(new he,e);return t.setChannel(r),r.setChannel(t),t}getConnectionString(){return"vaultys://memory"}fromConnectionString(e){return new he}async start(){}async send(e){for(;!this.otherend?.resolver;)await le(100);this.otherend?.resolver(e)}async receive(){return new Promise((e=>this.resolver=e))}async close(){}}var fe=r(35795);const ue=10,ge=e=>e.match(/.{1,4}/g)?.map((e=>parseInt(e,16).toString(2).padStart(16,"0")))||[],ye=e=>ge((0,i.hash)("sha256",(0,i.fromHex)(e.replaceAll(" ",""))).toString("hex")),de=(e,t)=>{const r=[];for(let s=0;s<16;s++){let n="";for(let r=0;r<16;r++){let i=0;for(let t=s-1;t<s+2;t++)for(let n=r-1;n<r+2;n++)t>-1&&t<16&&n>-1&&n<16&&(t==s&&n==r||"1"!=e[t][n]||i++);let a=!1;(3==i||2==i&&"1"==e[s][r])&&(a=!0),n+=a?"1":"O",t&&a&&t[s][r]++}r.push(n)}return r},pe=function(e,t,r){void 0===t&&(t=2);let s=1e3,n=0;const i=JSON.parse(JSON.stringify(e));for(let c=0;c<8;c++)for(let e=0;e<8;e++){i[c][e]=i[15-c][e]=i[c][15-e]=i[15-c][15-e]=i[c][e]+i[15-c][e]+i[c][15-e]+i[15-c][15-e];const t=i[c][e];t<s&&(s=t),t>n&&(n=t)}for(let c=0;c<16;c++)for(let e=0;e<16;e++){r.fillStyle=(a=Math.floor((i[c][e]-s)*t/n)/t,void 0===(o=n*n)&&(o=1),"hsl("+(240*(1-a)+o)+", 100%, 50%)");let l=0+e*ue,h=0+c*ue;r.fillRect(l,h,ue,ue)}var a,o},me={renderFingerprint:function(e,t,r){void 0===r&&(r=32);let s=ye(e.replaceAll(" ","")),n=s?.map((e=>e.split("").map((e=>parseInt(e)))));const i=t.getContext("2d");if(i&&n){for(let e=0;e<r;e++)s=de(s,n);return pe(n,3,i),t}},animateFingerprint:async function(e,t,r,s){void 0===r&&(r=32),void 0===s&&(s=500);let n=ye(e.replaceAll(" ","")),i=n?.map((e=>e.split("").map((e=>parseInt(e)))));const a=t.getContext("2d");if(a&&i){for(let e=0;e<r;e++)n=de(n,i),pe(i,3,a),await new Promise((e=>setTimeout(e,s)));return pe(i,3,a),t}}}},35795:(e,t,r)=>{"use strict";r.d(t,{DT:()=>l,XG:()=>c});var s=r(84686).Buffer;const n=(e,t)=>t?"certificate"===e?"__C__"+s.from(t).toString("base64"):"Buffer"===t.type?"_bx_"+s.from(t.data).toString("base64"):"Array"===t.constructor.name?"_bx_"+s.from(t).toString("base64"):t:t,i=(e,t)=>t&&"certificate"===e?"string"==typeof t&&t.startsWith("__C__")?s.from(t.slice(5),"base64"):s.from(t):"string"==typeof t&&t.startsWith("_bx_")?s.from(t.slice(4),"base64"):t,a=e=>JSON.stringify(e,n),o=e=>JSON.parse(e,i),c=e=>{let t={};return e||(e=()=>a(t)),h(t,e,(()=>""))},l=function(e){void 0===e&&(e="vaultysStorage");let t={};return localStorage[e]?t=o(localStorage[e]):localStorage[e]="{}",h(t,(()=>localStorage.setItem(e,a(t))),(()=>localStorage.removeItem(e)))},h=(e,t,r)=>({destroy:r,save:t,toString:()=>a(e),fromString:(e,t,r)=>h(o(e),t,r),_raw:e,set:(t,r)=>e[t]=r,delete:t=>delete e[t],get:t=>e[t],list:()=>Object.keys(e).filter((e=>!e.startsWith("!"))),listSubstores:()=>Object.keys(e).filter((e=>e.startsWith("!"))).map((e=>e.slice(1))),deleteSubstore:t=>delete e["!"+t],substore:s=>(e["!"+s]||(e["!"+s]={}),h(e["!"+s],t,r))})},75530:(e,t,r)=>{"use strict";r.r(t),r.d(t,{Buffer:()=>a.Buffer,fromBase64:()=>d,fromHex:()=>p,fromUTF8:()=>m,hash:()=>h,randomBytes:()=>l,secretbox:()=>f,toBase64:()=>u,toHex:()=>g,toUTF8:()=>y});var s=r(71899),n=r(35848),i=r.n(n),a=r(41408),o=r(76088),c=r(4150);const l=e=>a.Buffer.from(s.randomBytes?(0,s.randomBytes)(e):crypto.getRandomValues(new Uint8Array(e))),h=(e,t)=>a.Buffer.from((e=>{const t=e.replaceAll("-","").toLowerCase();return"sha256"===t?o.s.create():"sha512"===t?c.Zf.create():"sha224"===t?o.Z.create():o.s.create()})(e).update(t).digest()),f=i().secretbox,u=e=>a.Buffer.from(e).toString("base64"),g=e=>a.Buffer.from(e).toString("hex"),y=e=>a.Buffer.from(e).toString("utf-8"),d=e=>a.Buffer.from(e,"base64"),p=e=>a.Buffer.from(e,"hex"),m=e=>a.Buffer.from(e,"utf-8")},3459:(e,t,r)=>{"use strict";r.d(t,{Ay:()=>o,Yc:()=>a});var s=r(75530),n=r(84686).Buffer;const i=(e,t)=>{const r=t,i=(0,s.randomBytes)(s.secretbox.nonceLength),a=(0,s.secretbox)(Uint8Array.from(e),i,r),o=new Uint8Array(i.length+a.length);return o.set(i),o.set(a,i.length),n.from(o)},a=(e,t)=>{const r=t,i=e,a=i.slice(0,s.secretbox.nonceLength),o=i.slice(s.secretbox.nonceLength,e.length),c=s.secretbox.open(o,a,r);if(!c)throw new Error("Could not decrypt message");return n.from(c)},o={decrypt:a,encrypt:i,encryptChannel:(e,t)=>{const r={apply:(e,r,s)=>e.call(r,i(s[0],t))},s={async apply(e,r,s){const n=await e.call(r);return a(n,t)}};return e.send=new Proxy(e.send,r),e.receive=new Proxy(e.receive,s),e},generateKey:()=>(0,s.randomBytes)(32)}},24128:()=>{},4355:()=>{},71906:()=>{},68725:()=>{},49630:()=>{},9428:()=>{},26166:()=>{},34654:()=>{},34149:()=>{},89780:()=>{},99926:()=>{},90124:()=>{},71220:()=>{},38854:()=>{},92520:()=>{},37115:()=>{},60522:()=>{},70877:()=>{},87862:()=>{},77356:()=>{},22238:()=>{},71899:()=>{}}]);