(self.webpackChunksmartlink_doc=self.webpackChunksmartlink_doc||[]).push([[9493],{40452:(e,t,r)=>{"use strict";r.r(t),r.d(t,{assets:()=>v,contentTitle:()=>m,default:()=>k,frontMatter:()=>g,metadata:()=>w,toc:()=>b});var s=r(86070),a=r(25710),i=r(54380),n=r(4195),o=r(36760),c=r(57144),l=r(30758),h=r(92259),f=r(29916),d=r(74480),u=r(3836),y=r(84686).Buffer;const p=()=>{const[e,t]=(0,l.useState)(),[r,a]=(0,l.useState)(),[p,g]=(0,l.useState)(),[m,w]=(0,l.useState)(),[v,b]=(0,l.useState)(),[S,k]=(0,l.useState)(),[C,K]=(0,l.useState)(),[x,I]=(0,l.useState)(!1),[E,B]=(0,l.useState)(),[P,D]=(0,l.useState)(),N=(0,l.useRef)([]),[j,A]=(0,l.useState)(0),O=(e,t,r)=>async s=>{B(s.toString("base64"));const a=((e,t)=>(0,o.Yc)(e,t))(s,r);try{const t=(0,i.D4)(a);return D((0,d.du)(t)),e(t)}catch(n){return D(a.toString("utf-8")),t(a.toString("utf-8"))}},R=e=>{let{step:t=1,animate:r=!0}=e;return(0,s.jsxs)("div",{className:"w-full relative my-5",children:[(0,s.jsx)("span",{className:"absolute left-0 w-full bg-green-400 h-1"}),(0,s.jsx)("span",{className:(r?"animate-slide-right":"translate-x-0")+" absolute -top-3  h-8 w-full",children:(0,s.jsx)("span",{className:"bg-green-500 dark:bg-green-700 h-6 w-6 rounded-full px-2",children:t})})]})},M=e=>{let{step:t=2,animate:r=!0}=e;return(0,s.jsxs)("div",{className:"w-full relative my-5",children:[(0,s.jsx)("span",{className:"absolute left-0 w-full bg-green-400 h-1"}),(0,s.jsx)("span",{className:(r?"animate-slide-left":"-translate-x-full")+" absolute -top-3  h-8 w-full",children:(0,s.jsx)("span",{className:"bg-green-500 dark:bg-green-700 h-6 w-6 rounded-full px-2",children:t})})]})},T=e=>{let{error:t}=e;return(0,s.jsxs)("div",{className:"w-full relative my-5",children:[(0,s.jsx)("div",{className:"text-xs",children:t}),(0,s.jsx)("span",{className:"absolute left-0 w-full bg-red-400 h-1"})]})},_=(e,t)=>async r=>(N.current.push({direction:t,animate:!0}),A(Math.random()),await(0,d.cb)(2e3),e(r)),V=async function(s){if(void 0===s&&(s="software"),e)return;let a=await n.YC.generatePerson();const i=async()=>(alert("PRF"),!0);if("passkey"==s?a=await n.YC.createWebauthn(!0,i):"fido2"==s&&(a=await n.YC.createWebauthn(!1,i)),a){K(await(r?.vaultysId.encrypt("hello world",[a.id])));const e=(0,c.XG)((()=>{})),s=new n.VL(a,e);t(s)}};(0,l.useEffect)((()=>{(async()=>{if(!r){const e=await n.YC.generatePerson(),t=(0,c.XG)((()=>{})),r=new n.VL(e,t);a(r)}})()}),[]);const U=e=>{let{certificate:t}=e;return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)("li",{className:"flex flex-row items-center",children:["protocol ",[t?.protocol,t?.service].join(t?"/":"")]}),(0,s.jsxs)("li",{className:"flex flex-row items-center",children:[t?.pk1?(0,s.jsx)(h.maZ,{className:"-rotate-45 fill-green-500 h-8 w-8"}):(0,s.jsx)(h.maZ,{className:"-rotate-45 fill-slate-500 h-8 w-8"}),t?.sign1||t?.sign1?(0,s.jsx)(h.waL,{className:"fill-green-500 h-8 w-8"}):(0,s.jsx)(h.v6F,{className:"animate-spin fill-slate-500 h-8 w-8"}),"Bob"]}),(0,s.jsxs)("li",{className:"flex flex-row items-center",children:[t?.pk2?(0,s.jsx)(h.maZ,{className:"-rotate-45 fill-green-500 h-8 w-8"}):(0,s.jsx)(h.maZ,{className:"-rotate-45 fill-slate-500 h-8 w-8"}),t?.sign2?(0,s.jsx)(h.waL,{className:"fill-green-500 h-8 w-8"}):(0,s.jsx)(h.v6F,{className:"animate-spin fill-slate-500 h-8 w-8"}),"Alice"]})]})},F=e=>{let{id:t,name:r="Alice",sex:a="woman",certificate:i}=e;return t?(0,s.jsxs)("div",{className:"flex flex-col gap-5 items-center bg-slate-200 dark:bg-slate-800 rounded p-5",children:[(0,s.jsxs)("div",{className:" flex flex-col md:flex-row justify-center items-center gap-5",children:[(0,s.jsx)(f.A,{...(0,f.D)(t.vaultysId.fingerprint),hairStyle:"man"==a?"thick":"womanLong",hatStyle:"none",className:"w-20 h-20"}),r]}),(0,s.jsx)("div",{className:"font-mono text-xs font-bold w-48 hidden md:block",children:t.vaultysId.fingerprint}),(0,s.jsx)("div",{className:"w-full",children:0===i?(0,s.jsx)("div",{className:"bg-red-500 p-5 rounded border-red-700 dark:border-red-300 border-solid border",children:"Error"}):(0,s.jsx)(U,{certificate:i})})]}):(0,s.jsxs)("div",{className:"flex flex-col gap-5 items-center bg-slate-200 dark:bg-slate-800 rounded p-5",children:[(0,s.jsx)("div",{children:"Which way do you want to secure Bob Id?"}),(0,s.jsx)("button",{className:"p-2 rounded-lg cursor-pointer",onClick:()=>V("passkey"),children:"Passkey"}),(0,s.jsx)("button",{className:"p-2 rounded-lg cursor-pointer",onClick:()=>V("fido2"),children:"Fido2 Key"}),(0,s.jsx)("button",{className:"p-2 rounded-lg cursor-pointer transition-all",onClick:()=>V("software"),children:"Software"})]})};return(0,s.jsxs)("div",{className:"flex flex-col gap-5",children:[(0,s.jsxs)("div",{className:"grid grid-cols-3",children:[(0,s.jsx)(F,{name:"Bob",id:e,sex:"man",certificate:m}),(0,s.jsxs)("div",{className:"flex flex-col gap-5 text-center items-center",children:[(0,s.jsx)("button",{disabled:x||!e,className:"rounded bg-slate-300 dark:bg-slate-700 shadow-lg p-5 border-0 cursor-pointer hover:shadow-md active:shadow-none",onClick:()=>{(async()=>{if(!e||!r||!C)return;N.current=[],g(void 0),w(void 0);const t=o.Ay.generateKey();b(t);const s=u.n.createEncryptedBidirectionnal(t);I(!0),s.onSend=O(w,(()=>{}),t),s.onReceive=O(_(w,"alice"),_((()=>{}),"alice"),t),s.otherend.onSend=O(g,(()=>{}),t),s.otherend.onReceive=O(_(g,"bob"),_((()=>{}),"bob"),t);try{const[,t]=await Promise.all([e.acceptDecrypt(s),r.requestDecrypt(s.otherend,y.from(C,"utf-8"))]);k(t?.toString("utf-8"))}catch(a){N.current.push({direction:"error",animate:!1,error:a.message})}I(!1)})()},children:"Start"}),v&&(0,s.jsxs)("div",{className:"text-xs hidden lg:block",children:["Encryption key: ",v.toString("base64")]}),(()=>{const e=[],t=N.current;for(let r=0;r<t.length;r++)"bob"==t[r].direction?e.push((0,s.jsx)(R,{step:r+1,animate:t[r].animate},r)):"alice"==t[r].direction?e.push((0,s.jsx)(M,{step:r+1,animate:t[r].animate},r)):"error"==t[r].direction&&e.push((0,s.jsx)(T,{error:t[r].error},r)),N.current=N.current.map((e=>({...e,animate:!1})));return e})()]},j),(0,s.jsx)(F,{name:"Alice",sex:"woman",id:r,certificate:p})]}),(0,s.jsxs)("div",{children:[(0,s.jsx)("span",{className:"font-bold",children:"Encrypted for Bob:"})," ",C]}),(0,s.jsxs)("div",{children:[(0,s.jsx)("span",{className:"font-bold",children:"Decrypted by Bob:"})," ",S]}),(0,s.jsx)("div",{children:(0,s.jsx)("div",{className:"border border-slate-500 rounded border-solid p-5",children:(0,s.jsxs)("div",{className:"flex flex-col gap-5",children:[(0,s.jsx)("div",{className:"text-lg font-bold",children:"Exchanged Message"}),(0,s.jsx)("pre",{children:P})]})})})]})},g={hide_table_of_contents:!0,sidebar_position:5},m="Decrypt on Demand",w={id:"develop/try/decryptor",title:"Decrypt on Demand",description:"",source:"@site/docs/develop/try/decryptor.mdx",sourceDirName:"develop/try",slug:"/develop/try/decryptor",permalink:"/zh/docs/develop/try/decryptor",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:5,frontMatter:{hide_table_of_contents:!0,sidebar_position:5},sidebar:"userguideSidebar",previous:{title:"WebRTC",permalink:"/zh/docs/develop/try/webrtc"}},v={},b=[];function S(e){const t={h1:"h1",header:"header",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"decrypt-on-demand",children:"Decrypt on Demand"})}),"\n",(0,s.jsx)(p,{})]})}function k(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(S,{...e})}):S(e)}},3836:(e,t,r)=>{"use strict";r.d(t,{n:()=>i});var s=r(36760),a=r(74480);class i{setChannel(e,t,r,s){this.name=t,this.onSend=r,this.onReceive=s,this.otherend=e}static createBidirectionnal(){const e=new i,t=new i;return e.setChannel(t),t.setChannel(e),e}static createEncryptedBidirectionnal(e){e=e||s.Ay.generateKey();const t=s.Ay.encryptChannel(new i,e),r=s.Ay.encryptChannel(new i,e);return t.setChannel(r),r.setChannel(t),t}async send(e){for(;!this.otherend?.resolver;)await(0,a.cb)(10);this.onSend&&await this.onSend(e),this.otherend?.onReceive&&await(this.otherend?.onReceive(e)),this.otherend?.resolver(e)}async start(){}fromConnectionString(e){return new i}getConnectionString(){return""}async receive(){return new Promise((e=>this.resolver=e))}async close(){}}},74480:(e,t,r)=>{"use strict";r.d(t,{cb:()=>i,du:()=>c,vX:()=>o});var s=r(4195),a=r(84686).Buffer;const i=e=>new Promise((t=>setTimeout(t,e))),n=s.YC.createPublicKeyCredentialCreationOptions,o=async e=>{const t=await navigator.credentials.create({publicKey:n(e)});return t?await s.YC.fido2FromAttestation(t):null},c=e=>JSON.stringify(e,((e,t)=>t?.data&&"Buffer"==t?.type?a.from(t.data).toString("base64"):t),2)},4195:(e,t,r)=>{"use strict";r.d(t,{jC:()=>fe.Ay,VL:()=>ve,XG:()=>be.XG,YC:()=>Z,Et:()=>i});var s=r(23069),a=r(54987),i=r(98511),n=r(98408),o=r.n(n),c=r(35848),l=r.n(c),h=r(76855),f=r(88965),d=r(58988),u=r(66243),y=r(81840),p=r(10135),g=r(84686).Buffer;const m={},w=1,v=3,b=-1,S=-2,k=-3,C=1,K=2,x={1:d.s9,2:u.sL,3:y.Bt},I={"-257":"SHA-256","-258":"SHA-384","-259":"SHA-512","-65535":"SHA-1","-39":"SHA-512","-38":"SHA-384","-37":"SHA-256","-260":"SHA-256","-261":"SHA-512","-7":"SHA-256","-36":"SHA-512"},E=(e,t)=>(0,i.hash)(e.replace("-",""),t),B=e=>{const t=new p.yI(e),r=t.subject,s=t.issuer,a=t.issuerName.toString(),i=r.split(","),n={};for(const l of i){const e=l.split("=");n[e[0].trim()]=e[1]}const{Version:o}=t.toTextObject().Data,c=t.getExtension(p.WA);return{issuer:s,issuerName:a,subject:n,version:o,basicConstraintsCA:!!c&&c.ca}},P=e=>{const t=e.slice(0,32),r=(e=e.slice(32)).slice(0,1);e=e.slice(1);const s=r[0],a={up:!!(1&s),uv:!!(4&s),at:!!(64&s),ed:!!(128&s),flagsInt:s},i=e.slice(0,4);e=e.slice(4);const n=i.readUInt32BE(0);let o,c,l;if(a.at){o=e.slice(0,16);const t=(e=e.slice(16)).slice(0,2);e=e.slice(2);const r=t.readUInt16BE(0);c=e.slice(0,r),l=e=e.slice(r)}return{rpIdHash:t,flagsBuf:r,flags:a,counter:n,counterBuf:i,aaguid:o,credID:c,COSEPublicKey:l}};const D=(e,t,r)=>d.s9.verify(d.s9.Signature.fromDER(r).toCompactHex(),e,t),N=(e,t,r)=>f.ev.verify(r,e,t);class j{constructor(){this.signCount=0,this.rawId=(0,i.randomBytes)(32),this.aaguid=g.alloc(16)}static createRequest(e,t){void 0===t&&(t=!1);const r={publicKey:{challenge:g.from((0,i.randomBytes)(32).toString("base64")),rp:{name:"Vaultys ID",id:"Vaultys ID"},user:{id:g.from("Vaultys Wallet ID","utf8"),name:"Vaultys Wallet ID",displayName:"Vaultys Wallet ID"},pubKeyCredParams:[{type:"public-key",alg:e}]}};return t&&(r.publicKey.extensions={prf:{eval:{first:(0,i.randomBytes)(32)}}}),r}static getCertificateInfo(e){const t=g.from(e.attestationObject),r=o().decodeAllSync(t)[0];return r.attStmt.x5c?B(r.attStmt.x5c[0]):null}static async create(e,t){void 0===t&&(t="test");const r=new j,s=e.publicKey;if(r.options=s,r.rpId=s.rp.id,r.userHandle=g.from(s.user.id),m[r.rawId.toString("base64")]=r,r.alg=s.pubKeyCredParams[0].alg,-8===r.alg){const e=f.ev.utils.randomPrivateKey();r.keyPair={privateKey:e,publicKey:f.ev.getPublicKey(e)},r.coseKey=new Map,r.coseKey.set(1,1),r.coseKey.set(3,-8),r.coseKey.set(-1,6);const t=r.keyPair.publicKey.slice(0,32);r.coseKey.set(-2,t)}else if(-7===r.alg){const e=d.s9.utils.randomPrivateKey();r.keyPair={privateKey:e,publicKey:d.s9.getPublicKey(e,!1)},r.coseKey=new Map,r.coseKey.set(1,2),r.coseKey.set(3,-7),r.coseKey.set(-1,6);const t=r.keyPair.publicKey.slice(1,33),s=r.keyPair.publicKey.slice(33);r.coseKey.set(-2,t),r.coseKey.set(-3,s)}const a={type:"webauthn.create",challenge:s.challenge,origin:t},n=(0,i.hash)("sha256",g.from(r.rpId,"ascii")),c=g.from("41","hex"),l=g.allocUnsafe(4);l.writeUInt32BE(r.signCount);const h=g.allocUnsafe(2);h.writeUInt16BE(r.rawId.length);const u=o().encode(r.coseKey),y={authData:g.concat([n,c,l,r.aaguid,h,r.rawId,u]),fmt:"none",attStmt:{}};return{id:r.rawId.toString("base64"),rawId:r.rawId,authenticatorAttachment:null,type:"public-key",getClientExtensionResults:()=>s.extensions?.prf?.eval?.first?{prf:{enabled:!0}}:{},response:{clientDataJSON:g.from(JSON.stringify(a),"utf-8"),attestationObject:o().encode(y),getTransports:()=>["usb","hybrid"],getAuthenticatorData:()=>y.authData,getPublicKey:()=>u,getPublicKeyAlgorithm:()=>-7}}}static simpleVerify(e,t,r){void 0===r&&(r=!1);const s=o().decode(e,{extendedResults:!0}).value,a=(t.authenticatorData.slice(0,32),g.from(t.authenticatorData)[32]);t.authenticatorData.slice(33,37);if(!(r?!!(4&a):!!(1&a)))return!1;const n=(0,i.hash)("sha256",g.from(t.clientDataJSON));let c=g.concat([g.from(t.authenticatorData),n]);if(-7==s.get(3)&&(c=(0,i.hash)("sha256",c)),1==s.get(1)){const e=s.get(-2);return N(c,e,g.from(t.signature))}if(2==s.get(1)){const e=s.get(-2),r=s.get(-3),a=g.concat([g.from("04","hex"),e,r]);return D(c,a,g.from(t.signature))}return!1}static getCOSEPublicKey(e){const t=e.response,r=o().decode(t.attestationObject);return P(r.authData).COSEPublicKey}static verifyPackedAttestation(e,t){return void 0===t&&(t=!1),async function(e,t){void 0===t&&(t=!1);const r=g.from(e.attestationObject),s=o().decodeAllSync(r)[0];if("none"==s.fmt)return!1;const a=P(s.authData);if(!a.flags.up)return!1;if(t&&!a.flags.uv)return!1;const i=E("sha256",g.from(e.clientDataJSON)),n=g.concat([s.authData,i]),c=s.attStmt.sig;let l=!1;if(s.attStmt.x5c){const e=(e=>{let t="";for(let r=0;r<e.length;r+=64)t+=e.slice(r,r+64)+"\n";return"-----BEGIN CERTIFICATE-----\n"+t+"-----END CERTIFICATE-----"})(s.attStmt.x5c[0].toString("base64")),t=B(s.attStmt.x5c[0]),r=t.subject;if("Authenticator Attestation"!==r.OU)throw new Error('Batch certificate OU MUST be set strictly to "Authenticator Attestation"!');if(!r.CN)throw new Error("Batch certificate CN MUST no be empty!");if(!r.O)throw new Error("Batch certificate O MUST no be empty!");if(!r.C||2!==r.C.length)throw new Error("Batch certificate C MUST be set to two character ISO 3166 code!");if(t.basicConstraintsCA)throw new Error("Batch certificate basic constraints CA MUST be false!");if("v3 (2)"!==t.version)throw new Error("Batch certificate version MUST be 3(ASN1 2)!");l=h.createVerify("sha256").update(n).verify(e,c)}else{if(s.attStmt.ecdaaKeyId)throw new Error("ECDAA IS NOT SUPPORTED!");{const e=o().decodeAllSync(a.COSEPublicKey)[0],t=I[e.get(v)],r=E(t,n);if(e.get(w)===K){const t=e.get(S),s=e.get(k),a=g.concat([g.from([4]),t,s]),i=x[e.get(b)],n=i.Signature.fromDER(c);l=i.verify(n,r,a)}else{if(e.get(w)!==C)return!1;{const t=e.get(S);l=f.ev.verify(c,r,t)}}}}if(!l)throw new Error("Failed to verify the signature!");return!0}(e,t)}static verify(e,t,r){void 0===r&&(r=!1);const s=(0,i.hash)("sha256",g.from(t.response.clientDataJSON)),a=t.response,n=e.response;let c=g.concat([g.from(a.authenticatorData),s]);const l=o().decode(n.attestationObject),h=P(l.authData);if(!h.flags.up)return!1;if(r&&!h.flags.uv||!h.COSEPublicKey)return!1;const f=o().decode(h.COSEPublicKey);if(-7==f.get(3)&&(c=(0,i.hash)("sha256",c)),1==f.get(1)){const e=f.get(-2);return N(c,e,g.from(a.signature))}if(2==f.get(1)){const e=f.get(-2),t=f.get(-3),r=g.concat([g.from("04","hex"),e,t]);return D(c,r,g.from(a.signature))}}static extractChallenge(e){const t=JSON.parse(e.toString()),r=t.challenge.length%4;return t.challenge.replace(/-/g,"+").replace(/_/g,"/").padEnd(t.challenge.length+(0===r?0:4-r),"=")}static async get(e,t){let{publicKey:r}=e;if(void 0===t&&(t="test"),!r.allowCredentials)throw new Error;const s=g.from(r.allowCredentials[0].id).toString("base64"),a=m[s];a.signCount+=1;const n={type:"webauthn.get",challenge:g.from(r.challenge).toString("base64"),origin:t},o=(0,i.hash)("sha256",(0,i.fromUTF8)(JSON.stringify(n))),c=(0,i.hash)("sha256",g.from(a.rpId,"utf-8")),l=g.from("05","hex"),h=g.allocUnsafe(4);h.writeUInt32BE(a.signCount);const u=g.concat([c,l,h]),y=g.concat([u,o]);let p=new Uint8Array;-7===a.alg?p=d.s9.sign(y,a.keyPair.privateKey,{prehash:!0}).toDERRawBytes():-8===a.alg&&(p=f.ev.sign(y,a.keyPair.privateKey));return{id:s,rawId:g.from(s,"base64"),type:"public-key",authenticatorAttachment:null,getClientExtensionResults:()=>r.extensions?.prf?.eval?.first?{prf:{results:{first:E("sha256",r.extensions?.prf?.eval?.first)}}}:{},response:{authenticatorData:u,clientDataJSON:g.from(JSON.stringify(n),"utf-8"),signature:p,userHandle:a.userHandle}}}}var A=r(34919),O=r(41408),R=r(19048);const M=r.n(R)()??R,T=(e,t)=>{let r=e;return t.startsWith("m/")&&(t=t.slice(2)),t.split("/").forEach((e=>{r="'"==e[e.length-1]?r.derive(2147483648+parseInt(e.substring(0,e.length-1))):r.derive(parseInt(e))})),r};class _{level=1;version=1;capability="private";constructor(){this.authType="Ed25519VerificationKey2020",this.encType="X25519KeyAgreementKey2019"}static async create_Id25519_fromEntropy(e,t){void 0===t&&(t=0);const r=new _;r.entropy=e,r.level=1,r.capability="private";const s=(a=e,(0,i.hash)("sha512",a));var a;const n=T(await M.Bip32PrivateKey.fromEntropy(s.slice(0,32)),`m/1'/0'/${t}'`);r.proofKey={publicKey:n.toBip32PublicKey().toPublicKey().toBytes(),secretKey:n.toBytes()},r.swapIndex=t,r.proof=(0,i.hash)("sha256",r.proofKey.publicKey);const o=T(n,"/0'");r.signer={publicKey:o.toBip32PublicKey().toPublicKey().toBytes(),secretKey:o.toBytes()};const c=O.Buffer.alloc(8);c.writeBigInt64LE(BigInt(t));const h=(e=>(0,i.hash)("sha256",e))(O.Buffer.concat([s.slice(32,64),c])),f=l().box.keyPair.fromSecretKey(h);return r.cypher={publicKey:O.Buffer.from(f.publicKey),secretKey:O.Buffer.from(f.secretKey)},r}static generate_Id25519(){return _.create_Id25519_fromEntropy((0,i.randomBytes)(32))}get id(){return 0==this.version?(e=>{const t=O.Buffer.from([132,161,118,0]),r=O.Buffer.from([161,112,197,0,e.proof.length,...e.proof]),s=O.Buffer.from([161,120,197,0,e.signer.publicKey.length,...e.signer.publicKey]),a=O.Buffer.from([161,101,197,0,e.cypher.publicKey.length,...e.cypher.publicKey]);return O.Buffer.concat([t,r,s,a])})(this):O.Buffer.from((0,a.l)({v:this.version,p:this.proof,x:this.signer.publicKey,e:this.cypher.publicKey}))}async getCypher(){const e=this.cypher;return{hmac:t=>e.secretKey?(0,h.createHmac)("sha256",e.secretKey.toString("hex")).update("VaultysID/"+t+"/end").digest():void 0,signcrypt:async(t,r)=>(0,A.MO)(t,e,r),decrypt:async(t,r)=>(0,A.P_)(t,e,r)}}async getSigner(){const e=this.signer.secretKey;return new M.Bip32PrivateKey(e).toPrivateKey()}getSecret(){return O.Buffer.from((0,a.l)({v:this.version,p:this.proof,x:this.signer.secretKey,e:this.cypher.secretKey}))}static fromSecret(e){const t=(0,s.D4)(e),r=new _;r.version=t.v??0,r.level=2,r.capability="private",r.proof=t.p,r.signer={secretKey:t.x,publicKey:new M.Bip32PrivateKey(t.x).toBip32PublicKey().toPublicKey().toBytes()};const a=l().box.keyPair.fromSecretKey(t.e);return r.cypher={publicKey:O.Buffer.from(a.publicKey),secretKey:O.Buffer.from(a.secretKey)},r}static instantiate(e){const t=new _;return t.version=e.version??0,t.level=e.level,t.proof=e.proof.data?O.Buffer.from(e.proof.data):O.Buffer.from(e.proof),t.signer={publicKey:e.signer.publicKey.data?O.Buffer.from(e.signer.publicKey.data):O.Buffer.from(e.signer.publicKey)},t.cypher={publicKey:e.cypher.publicKey.data?O.Buffer.from(e.cypher.publicKey.data):O.Buffer.from(e.cypher.publicKey)},t}static fromId(e){const t=(0,s.D4)(e),r=new _;return r.version=t.v??0,r.level=2,r.capability="public",r.proof=t.p,r.signer={publicKey:t.x},r.cypher={publicKey:t.e},r}async sign(e){if("public"==this.capability)return null;return(await this.getSigner()).sign(e)}verify(e,t,r){return M.Bip32PublicKey.fromBytes(this.signer.publicKey).toPublicKey().verify(t,e)}async createSwapingCertificate(){if(1===this.level&&this.entropy){const e={newId:(await _.create_Id25519_fromEntropy(this.entropy,this.swapIndex+1)).id,proofKey:this.proofKey.publicKey,timestamp:Date.now(),signature:O.Buffer.from([])},t=O.Buffer.alloc(8);t.writeBigUInt64LE(BigInt(e.timestamp));const r=O.Buffer.concat([e.newId,e.proofKey,t]);return e.signature=new M.Bip32PrivateKey(this.proofKey.secretKey).toPrivateKey().sign(r),e}return null}async verifySwapingCertificate(e){if((0,i.hash)("sha256",e.proofKey).toString("hex")===this.proof.toString("hex")){const t=O.Buffer.alloc(8);t.writeBigUInt64LE(BigInt(e.timestamp));_.fromId(e.newId);const r=O.Buffer.concat([e.newId,e.proofKey,t]);return M.Bip32PublicKey.fromBytes(e.proofKey).toPublicKey().verify(r,e.signature)}return!1}cleanSecureData(){this.cypher?.secretKey&&((0,i.secureErase)(this.cypher.secretKey),delete this.cypher.secretKey),this.signer?.secretKey&&((0,i.secureErase)(this.signer.secretKey),delete this.signer.secretKey),this.entropy&&((0,i.secureErase)(this.entropy),delete this.entropy)}static async encrypt(e,t){const r=t.map(_.fromId).map((e=>e.cypher.publicKey));return await(0,A.MO)(e,null,r)}async signcrypt(e,t){const r=t.map(_.fromId).map((e=>e.cypher.publicKey)),s=await this.getCypher();return await s.signcrypt(e,r)}async decrypt(e,t){void 0===t&&(t=null);const r=await this.getCypher(),s=t?_.fromId(t).cypher.publicKey:null;return(await r.decrypt(e,s)).toString()}getSecretHash(e){const t=O.Buffer.concat([e,O.Buffer.from("secrethash"),this.cypher.secretKey]);return(0,i.hash)("sha256",t)}}var V=r(84686).Buffer;const U={usb:1,nfc:2,ble:4,internal:8,hybrid:16,"smart-card":32},F=e=>{const t=V.from([131,161,118,e.version]),r=V.concat([V.from([161,99,197,0,e.ckey.length]),e.ckey]),s=V.concat([V.from([161,101,197,0,e.cypher.publicKey.length]),e.cypher.publicKey]);return V.concat([t,r,s])},H=e=>Object.keys(U).filter((t=>e&&U[t])),L=e=>{const t=o().decode(e).get(1);return 1===t?"Ed25519VerificationKey2020":2===t?"P256VerificationKey2020":"Unknown"},W=e=>{const t=o().decode(e);let r=V.from([]);return-7==t.get(3)?r=V.concat([V.from("04","hex"),t.get(-2),t.get(-3)]):-8==t.get(3)&&(r=t.get(-2)),{publicKey:r}};class $ extends _{_transports=0;constructor(){super(),this.level=1,this.encType="X25519KeyAgreementKey2019"}get transports(){return H(this._transports)}static async createFromAttestation(e){const t=new $;t.ckey=j.getCOSEPublicKey(e),t.authType=L(t.ckey),t.fid=V.from(e.id,"base64");const r=e.response,s=r.getTransports?r.getTransports():["usb"];t._transports=(e=>e.reduceRight(((e,t)=>e+(U[t]?U[t]:0)),0))(s),t.signer=W(t.ckey);const a=(0,i.randomBytes)(32),n=(o=a,(0,i.hash)("sha512",o));var o;const c=l().box.keyPair.fromSecretKey(n.slice(0,32));return t.cypher={publicKey:V.from(c.publicKey),secretKey:V.from(c.secretKey)},t.entropy=a,t}get id(){return 0==this.version?F(this):V.from((0,a.l)({v:this.version,c:this.ckey,e:this.cypher.publicKey}))}get id_v0(){return F(this)}getSecret(){return V.from((0,a.l)({v:this.version,f:this.fid,t:this._transports,c:this.ckey,e:this.cypher.secretKey}))}static fromSecret(e){const t=(0,s.D4)(e),r=new $;r.version=t.v??0,r.capability="private",r.fid="string"==typeof t.f?V.from(t.f,"base64"):t.f,r._transports=t.t?t.t:15,r.ckey=t.c,r.authType=L(r.ckey),r.signer=W(t.c);const a=l().box.keyPair.fromSecretKey(t.e);return r.cypher={publicKey:V.from(a.publicKey),secretKey:V.from(a.secretKey)},r}static instantiate(e){const t=new $;return t.version=e.version??0,t.level=e.level,t.fid="string"==typeof e.fid?V.from(e.fid,"base64"):e.fid,t._transports=e.t?e.t:15,t.ckey=e.ckey.data?V.from(e.ckey.data):V.from(e.ckey),t.signer=W(t.ckey),t.authType=L(t.ckey),t.cypher={publicKey:e.cypher.publicKey.data?V.from(e.cypher.publicKey.data):V.from(e.cypher.publicKey)},t}static fromId(e){const t=(0,s.D4)(e),r=new $;return r.version=t.v??0,r.capability="public",r.fid="string"==typeof t.f?V.from(t.f,"base64"):t.f,r.ckey=t.c,r.signer=W(t.c),r.authType=L(r.ckey),r.cypher={publicKey:t.e},r}async getSigner(){return{sign:async e=>{if(!navigator.credentials)return null;try{await(window?.CredentialUserInteractionRequest())}catch(o){}const t={challenge:(0,i.hash)("sha256",e),userVerification:"preferred",allowCredentials:[{type:"public-key",id:this.fid,transports:H(this._transports)}]},{response:r}=await navigator.credentials.get({publicKey:t}),s=r,n={s:V.from(s.signature),c:V.from(s.clientDataJSON),a:V.from(s.authenticatorData)};return V.from((0,a.l)(n))}}}verify(e,t,r){void 0===r&&(r=!1);const a=(0,s.D4)(t),n={signature:a.s,clientDataJSON:a.c,authenticatorData:a.a,userHandle:V.from([])};return(0,i.hash)("sha256",e).toString("base64")===j.extractChallenge(n.clientDataJSON)&&j.simpleVerify(this.ckey,n,r)}verifyCredentials(e,t){if(void 0===t&&(t=!1),e.id!==this.fid.toString("base64"))return!1;const r=e.response;var s;return V.from(r.authenticatorData.slice(0,32)).toString("hex")===(s=V.from(e.id,"base64"),(0,i.hash)("sha256",s)).toString("hex")&&j.simpleVerify(this.ckey,r,t)}async createRevocationCertificate(){return null}}var J=r(84686).Buffer;const q={usb:1,nfc:2,ble:4,internal:8,hybrid:16,"smart-card":32},z=e=>{const t=o().decode(e,{extendedResults:!0}).value.get(1);return 1===t?"Ed25519VerificationKey2020":2===t?"P256VerificationKey2020":"Unknown"},Y=e=>{const t=o().decode(e,{extendedResults:!0}).value;let r=J.from([]);return-7==t.get(3)?r=J.concat([J.from("04","hex"),t.get(-2),t.get(-3)]):-8==t.get(3)&&(r=t.get(-2)),{publicKey:r}};class X extends ${prfsalt=(()=>J.from("VaultysID salt"))();constructor(){super()}static async createFromAttestation(e){const t=new X;t.ckey=j.getCOSEPublicKey(e),t.authType=z(t.ckey),t.fid=J.from(e.id,"base64");const r=e.response,s=r.getTransports?r.getTransports():["usb"];return t._transports=(e=>e.reduceRight(((e,t)=>e+(q[t]?q[t]:0)),0))(s),t.signer=Y(t.ckey),await t.getCypher(),delete t.cypher.secretKey,t}getSecret(){return J.from((0,a.l)({v:this.version,f:this.fid,t:this._transports,c:this.ckey,e:this.cypher.publicKey}))}static fromSecret(e){const t=(0,s.D4)(e),r=new X;return r.version=t.v??0,r.capability="private",r.fid="string"==typeof t.f?J.from(t.f,"base64"):t.f,r._transports=t.t?t.t:15,r.ckey=t.c,r.authType=z(r.ckey),r.signer=Y(t.c),r.cypher={publicKey:t.e},r}cleanSecureData(){this.cypher?.secretKey&&((0,i.secureErase)(this.cypher.secretKey),delete this.cypher.secretKey)}async getCypher(){if(!this.cypher?.secretKey){const t={challenge:J.from([]),userVerification:"preferred",allowCredentials:[{type:"public-key",id:this.fid,transports:(e=this._transports,Object.keys(q).filter((t=>e&&q[t])))}],extensions:{prf:{eval:{first:this.prfsalt}}}},r=await navigator.credentials.get({publicKey:t}),{prf:{results:{first:s}}}=r.getClientExtensionResults(),a=l().box.keyPair.fromSecretKey(J.from(s));this.cypher={publicKey:J.from(a.publicKey),secretKey:J.from(a.secretKey)}}var e;return super.getCypher()}async createRevocationCertificate(){return null}}var G=r(84686).Buffer;class Z{constructor(e,t,r){void 0===r&&(r=0),this.type=r,this.keyManager=e,this.certificate=t}static fromId(e,t,r){void 0===r&&(r="hex");let s=e;e.data&&(s=G.from(e.data)),e instanceof Uint8Array&&(s=G.from(e)),"string"==typeof e&&(s=G.from(e,r));const a=s[0];if(3==a){const e=$.fromId(s.slice(1));return new Z(e,t,a)}if(4==a){const e=X.fromId(s.slice(1));return new Z(e,t,a)}{const e=_.fromId(s.slice(1));return new Z(e,t,a)}}static createPublicKeyCredentialCreationOptions=e=>{const t=/^((?!chrome|android).)*applewebkit/i.test(navigator.userAgent),r=e?"client-device":"security-key";return{challenge:(0,i.randomBytes)(32),rp:{name:"Vaultys ID"},user:{id:(0,i.randomBytes)(16),name:"Vaultys ID",displayName:"Vaultys Wallet ID"},attestation:t?"none":"direct",authenticatorSelection:{authenticatorAttachment:e?"platform":"cross-platform",residentKey:e?"required":"discouraged",userVerification:"preferred"},hints:[r],extensions:{prf:{eval:{first:G.from("VaultysID salt","utf-8")}}},pubKeyCredParams:[{type:"public-key",alg:-7},{type:"public-key",alg:-8},{type:"public-key",alg:-257}]}};static async fromEntropy(e,t){const r=e,s=await _.create_Id25519_fromEntropy(r);return new Z(s,void 0,t)}static async createWebauthn(e,t){void 0===e&&(e=!0);const r=Z.createPublicKeyCredentialCreationOptions(e),s=await navigator.credentials.create({publicKey:r});return s?Z.fido2FromAttestation(s,t):null}static async fido2FromAttestation(e,t){if(await j.verifyPackedAttestation(e.response,!0),!e.getClientExtensionResults().prf?.enabled||t&&!await t()){const t=await $.createFromAttestation(e);return new Z(t,void 0,3)}{const t=await X.createFromAttestation(e);return new Z(t,void 0,4)}}static async machineFromEntropy(e){return Z.fromEntropy(e,0)}static async organizationFromEntropy(e){return Z.fromEntropy(e,2)}static async personFromEntropy(e){return Z.fromEntropy(e,1)}static fromSecret(e,t){void 0===t&&(t="hex");const r=G.from(e,t),s=r[0];if(3==s){const e=$.fromSecret(r.slice(1));return new Z(e,void 0,s)}if(4==s){const e=X.fromSecret(r.slice(1));return new Z(e,void 0,s)}{const e=_.fromSecret(r.slice(1));return new Z(e,void 0,s)}}static async generatePerson(){const e=await _.generate_Id25519();return new Z(e,void 0,1)}static async generateOrganization(){const e=await _.generate_Id25519();return new Z(e,void 0,2)}static async generateMachine(){const e=await _.generate_Id25519();return new Z(e,void 0,0)}get relationshipCertificate(){return this.certificate}getSecret(e){return void 0===e&&(e="hex"),G.concat([G.from([this.type]),this.keyManager.getSecret()]).toString(e)}get fingerprint(){return(G.from([this.type]).toString("hex")+(0,i.hash)("SHA224",this.keyManager.id).toString("hex")).slice(0,40).toUpperCase().match(/.{1,4}/g).join(" ")}get did(){return`did:vaultys:${(G.from([this.type]).toString("hex")+(0,i.hash)("SHA224",this.keyManager.id).toString("hex")).slice(0,40)}`}get didDocument(){return{"@context":["https://www.w3.org/ns/did/v1","https://w3id.org/security/suites/ed25519-2020/v1"],id:this.did,authentication:[{id:`${this.did}#keys-1`,type:this.keyManager.authType,controller:this.did,publicKeyMultibase:"m"+this.keyManager.signer.publicKey.toString("base64")}],keyAgreement:[{id:`${this.did}#keys-2`,type:this.keyManager.encType,controller:this.did,publicKeyMultibase:"m"+this.keyManager.cypher.publicKey.toString("base64")}]}}get id(){return G.concat([G.from([this.type]),this.keyManager.id])}toVersion(e){return this.keyManager.version=e,this}get version(){return this.keyManager.version}isHardware(){return 3===this.type||4===this.type}isMachine(){return 0===this.type}isPerson(){return 1===this.type}getOTPHmac(e){void 0===e&&(e=36e5);const t=Math.floor((new Date).getTime()/e);return this.keyManager.getSecretHash(G.from(`OTP-${t}`)).toString("hex")}getOTP(e,t){if(void 0===e&&(e="password"),void 0===t&&(t=864e5),this.certificate){const r=Math.floor((new Date).getTime()/t),s=G.concat([G.from(e,"utf-8"),G.from(this.certificate),G.from([r])]);return(0,i.hash)("SHA256",s).toString("hex")}throw new Error("no certificate, cannot derive OTP")}async signChallenge(e){"string"==typeof e&&(e=G.from(e,"hex"));const t=(0,i.hash)("sha256",G.concat([this.id,e]));return this.keyManager.sign(t)}verifyChallenge(e,t,r){"string"==typeof e&&(e=G.from(e,"hex")),"string"==typeof t&&(t=G.from(t,"hex"));const s=(0,i.hash)("sha256",G.concat([this.id,e]));return this.keyManager.verify(s,t,r)}async signcrypt(e,t){return this.keyManager.signcrypt(e,t.map((e=>"string"==typeof e?G.from(e.slice(2),"hex"):e.slice(1))))}static async encrypt(e,t){return _.encrypt(e,t.map((e=>"string"==typeof e?G.from(e.slice(2),"hex"):e.slice(1))))}encrypt=(()=>Z.encrypt)();async decrypt(e,t){let r;return t&&(r="string"==typeof t?G.from(t.slice(2)):t.subarray(1)),this.keyManager.decrypt(e,r)}async hmac(e){return(await this.keyManager.getCypher()).hmac(e)}}var Q=r(84686).Buffer,ee=r(65640);const te=-2,re=-1,se=(e,t)=>Q.concat([Q.from([160+e.length]),Q.from(e,"ascii"),Q.from([160+t.length]),Q.from(t,"ascii")]),ae=(e,t)=>Q.concat([Q.from([160+e.length]),Q.from(e,"ascii"),Q.from([197,t.length>>8,t.length]),t]),ie=(e,t)=>{const r=Q.concat([Q.from([160+e.length]),Q.from(e,"ascii")]);let s;if(t>=0&&t<=127)s=Q.from([t]);else if(t<0&&t>=-32)s=Q.from([t]);else if(t>0&&t<=255)s=Q.from([204,t]);else if(t>=-128&&t<=127)s=Q.from([208,t]);else if(t>0&&t<=65535)s=Q.from([205,t>>>8,t]);else if(t>=-32768&&t<=32767)s=Q.from([209,t>>>8,t]);else if(t>0&&t<=4294967295)s=Q.from([206,t>>>24,t>>>16,t>>>8,t]);else if(t>=-2147483648&&t<=2147483647)s=Q.from([210,t>>>24,t>>>16,t>>>8,t]);else if(t>0&&t<=0x10000000000000000){const e=t/2**32,r=t%2**32;s=Q.from([211,e>>>24,e>>>16,e>>>8,e,r>>>24,r>>>16,r>>>8,r])}else s=Q.from([0]);return Q.concat([r,s])},ne=e=>{let{protocol:t,service:r,timestamp:s,pk1:a,pk2:i,nonce:n,sign1:o,sign2:c,metadata:l}=e;return Q.concat([Q.from([137]),se("protocol",t),se("service",r),ie("timestamp",s),ae("pk1",a),ae("pk2",i),ae("nonce",n),ae("sign1",o),ae("sign2",c),Q.from([168]),Q.from("metadata","ascii"),Q.from([128])])},oe=e=>{const t={...(0,s.D4)(e),...{state:te,error:""}};try{if(t.timestamp&&t.protocol&&t.service)if(t.pk2||!t.pk1||t.sign1||t.sign2||16!==t.nonce?.length){if(!t.sign1&&32===t.nonce?.length&&t.pk1&&t.pk2&&t.sign2){t.state=1;const e=Z.fromId(t.pk2),r=ce(t,e.version);e.verifyChallenge(r,t.sign2,!0)||(t.state=te,t.error="[STEP1] failed the verification of pk2")}else if(t.sign1&&32===t.nonce?.length&&t.pk1&&t.pk2&&t.sign2){t.state=2;const e=Z.fromId(t.pk1),r=Z.fromId(t.pk2);e.version!==r.version&&(t.state=te,t.error="[COMPLETE] pk1 and pk2 are using different serialization version");const s=ce(t,e.version);r.verifyChallenge(s,t.sign2,!0)||(t.state=te,t.error="[COMPLETE] failed the verification of pk2"),e.verifyChallenge(s,t.sign1,!0)||(t.state=te,t.error="[COMPLETE] failed the verification of pk1")}}else t.state=0;else t.state=te,t.error="[ERROR] Challenge is missing values"}catch(r){t.error="["+t.state+" -> ERROR] "+r,t.state=te}return t},ce=function(e,t){void 0===t&&(t=0);const{protocol:r,service:s,timestamp:i,pk1:n,pk2:o,nonce:c,metadata:l}=e,h={protocol:r,service:s,timestamp:i,pk1:n,pk2:o,nonce:c,metadata:l};return 0===t?(e=>{let{protocol:t,service:r,timestamp:s,pk1:a,pk2:i,nonce:n,metadata:o}=e;return Q.concat([Q.from([135]),se("protocol",t),se("service",r),ie("timestamp",s),ae("pk1",a),ae("pk2",i),ae("nonce",n),Q.from([168]),Q.from("metadata","ascii"),Q.from([128])])})(h):Q.from((0,a.l)(h))},le=function(e,t,r){return void 0===r&&(r=Date.now()),e.timestamp>r-t&&e.timestamp<r+t};class he{constructor(e,t){void 0===t&&(t=6e4),this.state=re,this.vaultysId=e,this.liveliness=t}static async verifyCertificate(e){return 2===oe(e).state}static async fromCertificate(e,t){const r=oe(e);if(0===r.state){const e=new he(Z.fromId(r.pk1).toVersion(0),t);e.challenge=r,e.mykey=r.pk1,e.state=0}else if(1===r.state){const e=new he(Z.fromId(r.pk2).toVersion(0),t);return e.challenge=r,e.mykey=r.pk2,e.hisKey=r.pk1,e.state=1,e}}static deserializeCertificate=(()=>oe)();static serializeCertificate_v0=(()=>ne)();static serializeCertificate=(()=>ce)();async setChallenge(e){if(this.state!==re)throw this.state=te,new Error("Challenger already initialised, can't reset the state");if(this.challenge=oe(e),!le(this.challenge,this.liveliness))throw this.state=te,this.challenge.error="challenge timestamp failed the liveliness at first signature",new Error(this.challenge.error);if(this.challenge.state===te)throw this.state=te,new Error(this.challenge.error);if(0===this.challenge.state){this.mykey=this.vaultysId.id,this.challenge.pk2=this.mykey,this.hisKey=this.challenge.pk1,this.challenge.nonce=Q.concat([this.challenge.nonce||new Uint8Array,(0,i.randomBytes)(16)]);const e=this.getUnsignedChallenge();if(!e)throw new Error("Error processing Challenge");this.challenge.sign2=await this.vaultysId.signChallenge(e)||void 0,this.challenge.state=this.state=1}else{if(2!==this.challenge.state)throw new Error("Challenge is from a protocol already launched, this is completely unsafe");if(this.mykey=this.vaultysId.id,!this.challenge.pk1?.equals(this.mykey)&&!this.challenge.pk1?.equals(this.mykey))throw this.state=te,new Error("Can't link the vaultys id to this challenge");this.state=2}}getContext(){return{protocol:this.challenge?.protocol,service:this.challenge?.service,metadata:this.challenge?.metadata}}createChallenge(e,t,r,s){if(void 0===r&&(r=1),void 0===s&&(s={}),this.state!=re)throw this.state=te,new Error("Challenger already initialised, can't reset the state");this.mykey=this.vaultysId.toVersion(r).id,this.challenge={protocol:e,service:t,metadata:s,timestamp:Date.now(),pk1:this.mykey,nonce:(0,i.randomBytes)(16),state:0},this.state=0}getCertificate(){return this.challenge?Q.from((e=>{if(0==e.state){const{protocol:t,service:r,timestamp:s,pk1:i,nonce:n,metadata:o}=e,c={protocol:t,service:r,timestamp:s,pk1:i,nonce:n,metadata:o},l=(0,a.l)(c);return Q.from(l)}if(1==e.state){const{protocol:t,service:r,timestamp:s,pk1:i,pk2:n,nonce:o,sign2:c,metadata:l}=e,h={protocol:t,service:r,timestamp:s,pk1:i,pk2:n,nonce:o,sign2:c,metadata:l},f=(0,a.l)(h);return Q.from(f)}if(2==e.state){const{protocol:t,service:r,timestamp:s,pk1:i,pk2:n,nonce:o,sign1:c,sign2:l,metadata:h}=e,f={protocol:t,service:r,timestamp:s,pk1:i,pk2:n,nonce:o,sign1:c,sign2:l,metadata:h},d=(0,a.l)(f);return Q.from(d)}return null})(this.challenge)||[]):Q.from([])}getUnsignedChallenge(){return ce(this.challenge,this.vaultysId.version)}getContactDid(){return this.hisKey?Z.fromId(this.hisKey).did:null}getContactId(){if(this.isComplete()){return Z.fromId(this.hisKey,this.getCertificate()||void 0)}throw new Error("The challenge is not COMPLETE, it is unsafe to get the Contact ID before")}static fromString(e,t){const r=new he(e);return r.setChallenge(t),r}hasFailed(){return this.state==te}isComplete(){return 2==this.state}isSelfAuth(){return this.mykey?.toString("hex")==this.hisKey?.toString("hex")}async init(e){if(this.state!==re)throw new Error("Can't init INITIALISED challenge");const t=oe(e);if(0===t.state){if(t.pk2?.toString("base64")!==this.vaultysId.id.toString("base64"))throw this.state=te,new Error("challenge is not corresponding to the right id");return this.challenge=t,this.mykey=this.challenge.pk2=this.vaultysId.id,this.hisKey=this.challenge.pk1,void(this.challenge.state=this.state=0)}if(1===t.state){if(t.pk2?.toString("base64")!==this.vaultysId.id.toString("base64"))throw this.state=te,new Error("challenge is not corresponding to the right id");return this.challenge=t,this.mykey=this.challenge.pk2,this.hisKey=this.challenge.pk1,void(this.state=this.challenge.state=1)}}async update(e,t){if(void 0===t&&(t={}),this.state===te)throw new Error("Can't update ERRORneous challenge");if(2===this.state)throw new Error("Can't update COMPLETE challenge");{const t=oe(e);if(!t)throw this.state=te,new Error("Can't read the new incoming challenge");if(t.state===te)throw this.state=te,new Error(t.error);if(!le(t,this.liveliness))throw this.state=te,new Error("challenge timestamp failed the liveliness");if(this.state===re&&0===t.state){this.challenge=t,this.mykey=this.challenge.pk2=this.vaultysId.id,this.hisKey=this.challenge.pk1,this.challenge.nonce=Q.concat([this.challenge.nonce,(0,i.randomBytes)(16)]);const e=this.getUnsignedChallenge();return this.challenge.sign2=await this.vaultysId.signChallenge(e),void(this.challenge.state=this.state=1)}if(this.state===re&&1===t.state){if(t.pk1?.toString("base64")!==this.vaultysId.id.toString("base64"))throw this.state=te,new Error("challenge is not corresponding to the right id");const e=ce(t,this.vaultysId.version);return t.sign1=await this.vaultysId.signChallenge(e),this.challenge=t,this.mykey=this.challenge.pk1,this.hisKey=this.challenge.pk2,void(this.state=this.challenge.state=2)}if(this.state===re&&2===t.state)return void ee.log("COMPLETE case?!!");if(t.protocol!==this.challenge.protocol||t.service!==this.challenge.service)throw this.state=te,new Error(`The challenge was expecting protocol '${this.challenge.protocol}' and service '${this.challenge.service}', received '${t.protocol}' and '${t.service}'`);if(0===this.state&&1===t.state){if(!t.nonce?.subarray(0,16).equals(this.challenge.nonce.subarray(0,16)))throw this.state=te,new Error("Nonce has been tampered with");if(t.timestamp!==this.challenge?.timestamp)throw this.state=te,new Error("Timestamp has been tampered with");if(!this.mykey?.equals(t.pk1))throw this.state=te,new Error(`The challenge has been tampered with. Received pk1 = '${t.pk1}', expected pk1 = '${this.mykey}'`);const e=ce(t,this.vaultysId.version);if(!e)throw this.state=te,new Error("Error processing Challenge");t.sign1=await this.vaultysId.signChallenge(e),this.challenge=t,this.hisKey=t.pk2,this.state=this.challenge.state=2}else{if(1!==this.state||2!==t.state){ee.log(t);const e=`The challenge is in an expected state. Received state = '${t.state}', expected state = '${this.state+1}'`;throw this.state=te,new Error(e)}if(t.protocol!==this.challenge.protocol||t.service!==this.challenge.service)throw this.state=te,new Error(`The challenge was expecting protocol '${this.challenge.protocol}' and service '${this.challenge.service}', received '${t.protocol}' and '${t.service}'`);if(!t.nonce?.subarray(16,32).equals(this.challenge.nonce.subarray(16,32)))throw this.state=te,new Error("Nonce has been tampered with");if(t.timestamp!==this.challenge?.timestamp)throw this.state=te,new Error("Timestamp has been tampered with");if(!this.mykey.equals(t.pk2))throw this.state=te,new Error("The challenge pk2 has been tampered with");this.challenge=t,this.state=2}}}}var fe=r(36760),de=r(40896),ue=r(84686).Buffer;r(65640);function ye(e){const t=()=>new de.Stream.Writable({write:(t,r,s)=>{e.send(t),s()}}),r=async r=>new Promise((s=>{const a=t();r.pipe(a).once("finish",(()=>{e.send(ue.from("EOF","utf-8")),a.end(),s()}))})),s=()=>{let t,r;const s=new de.Stream.Readable({read(){t=e=>this.push(e)}});return(async t=>{let r=await e.receive();for(;r;){if(t(r),"EOF"===r.toString("utf-8"))return;r=await e.receive()}})((e=>{3===e.length&&"EOF"===e.toString("utf-8")&&t&&(r&&t(r),t(null),s.destroy()),r=r?ue.concat([r,e]):e,t&&(!t(r)&&(t=null),r=null)})),s};return{getReadStream:s,getWriteStream:t,upload:r,uploadData:async e=>{const t=de.Readable.from(e);await r(t)},download:async e=>{const t=s(),r=new Promise((e=>t.on("end",(()=>{e()}))));t.pipe(e),await r},downloadData:async()=>{const e=s(),t=[],r=new Promise((r=>e.on("end",(()=>{r(ue.concat(t))})))),a=new de.Stream.Writable({write:(e,r,s)=>{t.push(e),s()}});return e.pipe(a),r}}}var pe=r(84686).Buffer;const ge=e=>e.startsWith("vaultys://connect?")?"LOGIN":e.startsWith("vaultys://signfile?")?"DOCUMENT":"UNKNOWN",me=e=>{let t;return t=3===e.type?new Z($.instantiate(e.keyManager),e.certificate,e.type):4===e.type?new Z(X.instantiate(e.keyManager),e.certificate,e.type):new Z(_.instantiate(e.keyManager),e.certificate,e.type),t},we=e=>Z.fromId(pe.from(e.serverId,"base64"),e.certificate);class ve{constructor(e,t){this.vaultysId=e,this.store=t,this.store.get("metadata")||this.store.set("metadata",{}),this.vaultysId.keyManager.entropy?this.store.set("entropy",this.vaultysId.keyManager.entropy):this.store.set("secret",this.vaultysId.getSecret()),this.store.save()}static async fromStore(e){const t=e.get("entropy"),r=e.get("secret");if(r){if(t){const s=pe.from(r,"base64")[0],a=await Z.fromEntropy(t,s);return new ve(a,e)}{const t=Z.fromSecret(r);return new ve(t,e)}}if(t){const r=await Z.machineFromEntropy(t);return new ve(r,e)}{const t=await Z.generateMachine();return new ve(t,e)}}merge(e,t){void 0===t&&(t=!0);const r=t?e:this.store,s=t?this.store:e;this.store.set("metadata",{...s.get("metadata"),...r.get("metadata")}),["signatures","wot"].forEach((t=>{const r=e.substore(t),s=this.store.substore(t);r.list().forEach((e=>{s.get(e)||s.set(e,r.get(e))}))}));const a=e.substore("contacts"),i=this.store.substore("contacts"),n=t?a:i,o=t?i:a;a.list().forEach((e=>{if(i.get(e)){const t=i.get(e);t.metadata={...o.get(e).metadata,...n.get(e).metadata},i.set(e,t)}else i.set(e,a.get(e))})),this.store.save()}isHardware(){return this.vaultysId.isHardware()}async signIn(){if(!this.vaultysId.isHardware())return!0;await window.CredentialUserInteractionRequest();const e=(0,i.randomBytes)(32),t=this.vaultysId.keyManager,r=await navigator.credentials.get({publicKey:{challenge:e,allowCredentials:[{type:"public-key",id:t.fid,transports:t.transports}],userVerification:"discouraged"}});if(null==r)return!1;const s=r.response,a=j.extractChallenge(pe.from(s.clientDataJSON));return e.toString("base64")===a&&t.verifyCredentials(r)}get contacts(){const e=this.store.substore("contacts");return e.list().map((t=>e.get(t))).map(me).map((e=>e.toVersion(this.vaultysId.version)))}get apps(){const e=this.store.substore("registrations");return e.list().map((t=>e.get(t))).map(we).map((e=>e.toVersion(this.vaultysId.version)))}getContact(e){const t=this.store.substore("contacts").get(e);return t?me(t).toVersion(this.vaultysId.version):null}getApp(e){const t=this.store.substore("registrations").get(e);return t?we(t).toVersion(this.vaultysId.version):null}setContactMetadata(e,t,r){const s=this.store.substore("contacts").get(e);s&&(s.metadata||(s.metadata={}),s.metadata[t]=r)}getContactMetadata(e,t){const r=this.store.substore("contacts").get(e);return r&&r.metadata?r.metadata[t]:null}getContactMetadatas(e){const t=this.store.substore("contacts").get(e);return t&&t.metadata?t.metadata:null}async verifyRelationshipCertificate(e){const t=this.store.substore("contacts").get(e)||this.store.substore("registrations").get(e);return he.verifyCertificate(t.certificate)}set name(e){this.store.get("metadata").name=e}get name(){return this.store.get("metadata").name}get displayName(){const e=this.store.get("metadata"),t=e.firstname?e.firstname+" "+(e.name??""):e.name;return t?.length>0?t:"Anonymous "+this.vaultysId.fingerprint?.slice(-4)}set phone(e){this.store.get("metadata").phone=e}get phone(){return this.store.get("metadata").phone}set email(e){this.store.get("metadata").email=e}get email(){return this.store.get("metadata").email}async signChallenge(e){const t=await this.vaultysId.signChallenge(e);return this.store.substore("signatures").set(""+Date.now(),{signature:t,challenge:e}),this.store.save(),t}async signFile(e){const t=(0,i.hash)("sha256",e.arrayBuffer).toString("hex"),r=pe.from(`vaultys://signfile?hash=${t}&timestamp=${Date.now()}`,"utf-8"),s={challenge:r,signature:await this.vaultysId.signChallenge(r)};return this.store.substore("signatures").set(Date.now()+"",s),this.store.save(),s}verifyFile(e,t,r,s){void 0===s&&(s=!0);const a=t.challenge.toString("utf8");if(!a.startsWith("vaultys://signfile?"))return!1;const n=(0,i.hash)("sha256",e.arrayBuffer).toString("hex"),o=new URL(a);return n===o.searchParams.get("hash")&&(!(2!==o.search.match(/[a-z\d]+=[a-z\d]+/gi)?.length||!o.searchParams.get("timestamp"))&&r.verifyChallenge(t.challenge,t.signature,s))}getSignatures(){const e=this.store.substore("signatures");return e.list().sort().map((t=>{const r=e.get(t),s=pe.from(r.challenge).toString("utf-8");return{date:t,payload:r,challenge:s,type:ge(s)}}))}migrate(e){this.vaultysId.toVersion(e);const t=this.store.substore("contacts");for(const s of t.list()){const r=t.get(s),a=me(r),i=a.toVersion(e);i.did!==s&&(t.set(i.did,{...a,...i,metadata:r.metadata,oldDid:s}),t.delete(s))}const r=this.store.substore("registrations");for(const s of r.list()){const t=r.get(s),a=we(t);if(a){const i=a.toVersion(e);if(i.did!==s){const e=t.site===s?i.did:t.site;r.set(i.did,{site:e,oldDid:s,serverId:i.id.toString("base64"),certificate:t.certificate,timestamp:t.timestamp}),r.delete(s)}}}this.store.save()}async verifyChallenge(e,t){return this.vaultysId.verifyChallenge(e,t,!0)}async sync(e,t){if(void 0===t&&(t=!1),t){const r=await this.startSRP(e,"p2p","selfauth");if(r.isSelfAuth()&&r.isComplete()){const r=this.store.fromString((await e.receive()).toString("utf-8"));e.send(pe.from(this.store.toString(),"utf-8")),this.merge(r,!t)}}else{const r=await this.acceptSRP(e,"p2p","selfauth");if(r.isSelfAuth()&&r.isComplete()){e.send(pe.from(this.store.toString(),"utf-8"));const r=this.store.fromString((await e.receive()).toString("utf-8"));this.merge(r,!t)}e.close()}this.store.save()}async upload(e,t){if((await this.startSRP(e,"p2p","transfer")).isComplete()){const{upload:r}=ye(e);await r(t)}else e.send(pe.from([0]))}async download(e,t){if((await this.acceptSRP(e,"p2p","transfer")).isComplete()){const{download:r}=ye(e);await r(t)}else e.send(pe.from([0]))}async requestDecrypt(e,t){if((await this.acceptSRP(e,"p2p","decrypt")).isComplete()){e.send(t);const r=await e.receive(),s=await this.vaultysId.decrypt(r.toString("utf-8"));return pe.from(s??"","utf-8")}e.send(pe.from([0]))}async acceptDecrypt(e,t){const r=await this.startSRP(e,"p2p","decrypt");if(r.isComplete()){if(!t||await t(r.getContactId())){const t=await e.receive(),s=await this.vaultysId.decrypt(t.toString("utf-8"));if(s){const t=await this.vaultysId.encrypt(s,[r.getContactId().id]);e.send(pe.from(t??"","utf-8"))}else e.send(pe.from([0]))}}else e.send(pe.from([0]))}async requestSignFile(e,t){const r=await this.acceptSRP(e,"p2p","signfile");if(r.isComplete()){e.send(pe.from((0,a.l)(t)));const i=await e.receive(),n=(0,s.D4)(i);return this.verifyFile(t,n,r.getContactId().toVersion(1))?n:void 0}e.send(pe.from([0]))}async acceptSignFile(e,t){const r=await this.startSRP(e,"p2p","signfile");if(r.isComplete()){const i=await e.receive(),n=(0,s.D4)(i);if(!t||await t(r.getContactId(),n)){const t=await this.signFile(n);e.send(pe.from((0,a.l)(t)))}}else e.send(pe.from([0]))}async requestPRF(e,t){if(t.length<3)throw new Error("appid is too short, less than 3 characters");if(t.split("-").length>1)throw new Error("appid contains illegal character /");if((await this.acceptSRP(e,"p2p","prf")).isComplete()){e.send(pe.from(t,"utf-8"));const r=await e.receive();return pe.from(r)}e.send(pe.from([0]))}async acceptPRF(e,t){const r=await this.startSRP(e,"p2p","prf");if(r.isComplete()){const s=(await e.receive()).toString("utf-8");if(s.length<3||s.split("-").length>1)e.send(pe.from([0]));else if(!t||await t(r.getContactId(),s)){const t=await this.vaultysId.hmac("prf/"+s+"/end")??pe.from([0]);e.send(t)}}else e.send(pe.from([0]))}listCertificates(){const e=this.store.substore("wot");return e.list().map((t=>{const r=e.get(t);if(r.timestamp)return r;{const s={...he.deserializeCertificate(e.get(t)),raw:r};return e.set(t,s),s}}))}async startSRP(e,t,r,s){void 0===s&&(s={});const a=Z.fromSecret(this.vaultysId.getSecret()).toVersion(0),i=new he(a);i.createChallenge(t,r,0,s);const n=i.getCertificate();if(!n)throw e.close(),e.send(pe.from([0])),new Error("Error processing challenge");e.send(n);try{const t=await e.receive();await i.update(t)}catch(o){throw await e.send(pe.from([0])),new Error(o)}if(i.isComplete()){const t=i.getCertificate();if(!t)throw e.close(),await e.send(pe.from([0])),new Error("Error processing challenge");return await e.send(t),this.store.substore("wot").set(Date.now()+"",t),i}throw await e.send(pe.from([0])),new Error("Can't add a new contact if the protocol is not complete")}async acceptSRP(e,t,r,s){void 0===s&&(s={});const a=Z.fromSecret(this.vaultysId.getSecret()).toVersion(0),i=new he(a);try{const t=await e.receive();await i.update(t)}catch(o){throw await e.send(pe.from([0])),new Error(o)}const n=i.getCertificate();if(!n)throw await e.send(pe.from([0])),await e.close(),new Error("Error processing challenge");await e.send(n);try{const t=await e.receive();await i.update(t)}catch(o){throw await e.close(),new Error(o)}if(i.isComplete()){const e=i.getCertificate();return this.store.substore("wot").set(Date.now()+"",e),i}throw await e.close(),new Error("Can't add a new contact if the protocol is not complete")}saveApp(e,t){if(e.toVersion(this.vaultysId.version),e.isMachine()){const r=this.store.substore("registrations");r.get(e.did)||r.set(e.did,{site:t??e.did,serverId:e.id.toString("base64"),certificate:e.certificate})}else this.saveContact(e)}saveContact(e){if(e.toVersion(this.vaultysId.version),e.isMachine())this.saveApp(e);else{const t=this.store.substore("contacts");t.get(e.did)||(t.set(e.did,e),this.store.save())}}async askContact(e,t){void 0===t&&(t={});const r=(await this.startSRP(e,"p2p","auth")).getContactId();return this.saveContact(r),r}async acceptContact(e,t){void 0===t&&(t={});const r=(await this.acceptSRP(e,"p2p","auth")).getContactId();return this.saveContact(r),r}async askMyself(e){const t=await this.startSRP(e,"p2p","selfauth");return t.isSelfAuth()&&t.isComplete()}async acceptMyself(e){const t=await this.acceptSRP(e,"p2p","selfauth");return t.isSelfAuth()&&t.isComplete()}}var be=r(57144)},57144:(e,t,r)=>{"use strict";r.d(t,{DT:()=>l,XG:()=>c});var s=r(84686).Buffer;const a=(e,t)=>t?"certificate"===e?"__C__"+s.from(t).toString("base64"):"Buffer"===t.type?"_bx_"+s.from(t.data).toString("base64"):"Array"===t.constructor.name?"_bx_"+s.from(t).toString("base64"):t:t,i=(e,t)=>t&&"certificate"===e?"string"==typeof t&&t.startsWith("__C__")?s.from(t.slice(5),"base64"):s.from(t):"string"==typeof t&&t.startsWith("_bx_")?s.from(t.slice(4),"base64"):t,n=e=>JSON.stringify(e,a),o=e=>JSON.parse(e,i),c=e=>{let t={};return e||(e=()=>n(t)),h(t,e,(()=>""))},l=function(e){void 0===e&&(e="vaultysStorage");let t={};Math.random();return localStorage[e]?t=o(localStorage[e]):localStorage[e]="{}",h(t,(()=>{localStorage.setItem(e,n(t))}),(()=>localStorage.removeItem(e)))},h=(e,t,r)=>({destroy:r,save:t,toString:()=>n(e),fromString:(e,t,r)=>h(o(e),t,r),_raw:e,set:(t,r)=>e[t]=r,delete:t=>delete e[t],get:t=>e[t],list:()=>Object.keys(e).filter((e=>!e.startsWith("!"))),listSubstores:()=>Object.keys(e).filter((e=>e.startsWith("!"))).map((e=>e.slice(1))),deleteSubstore:t=>delete e["!"+t],renameSubstore:(t,r)=>{t===r||e["!"+r]||(e["!"+r]=e["!"+t],delete e["!"+t])},substore:s=>(e["!"+s]||(e["!"+s]={}),h(e["!"+s],t,r))})},98511:(e,t,r)=>{"use strict";r.r(t),r.d(t,{Buffer:()=>n.Buffer,fromBase64:()=>p,fromHex:()=>g,fromUTF8:()=>m,hash:()=>h,randomBytes:()=>l,secretbox:()=>f,secureErase:()=>w,toBase64:()=>d,toHex:()=>u,toUTF8:()=>y});var s=r(76855),a=r(35848),i=r.n(a),n=r(41408),o=r(76088),c=r(4150);const l=e=>n.Buffer.from(s.randomBytes?(0,s.randomBytes)(e):crypto.getRandomValues(new Uint8Array(e))),h=(e,t)=>n.Buffer.from((e=>{const t=e.replaceAll("-","").toLowerCase();return"sha256"===t?o.s.create():"sha512"===t?c.Zf.create():"sha224"===t?o.Z.create():o.s.create()})(e).update(t).digest()),f=i().secretbox,d=e=>n.Buffer.from(e).toString("base64"),u=e=>n.Buffer.from(e).toString("hex"),y=e=>n.Buffer.from(e).toString("utf-8"),p=e=>n.Buffer.from(e,"base64"),g=e=>n.Buffer.from(e,"hex"),m=e=>n.Buffer.from(e,"utf-8"),w=e=>{for(let t=0;t<e.length;t++)e[t]=0}},36760:(e,t,r)=>{"use strict";r.d(t,{Ay:()=>o,Yc:()=>n});var s=r(98511),a=r(84686).Buffer;const i=(e,t)=>{const r=t,i=(0,s.randomBytes)(s.secretbox.nonceLength),n=(0,s.secretbox)(Uint8Array.from(e),i,r),o=new Uint8Array(i.length+n.length);return o.set(i),o.set(n,i.length),a.from(o)},n=(e,t)=>{const r=t,i=e,n=i.slice(0,s.secretbox.nonceLength),o=i.slice(s.secretbox.nonceLength,e.length),c=s.secretbox.open(o,n,r);if(!c)throw new Error("Could not decrypt message");return a.from(c)},o={decrypt:n,encrypt:i,encryptChannel:(e,t)=>{const r={apply:(e,r,s)=>e.call(r,i(s[0],t))},s={async apply(e,r,s){const a=await e.call(r);return n(a,t)}};return e.send=new Proxy(e.send,r),e.receive=new Proxy(e.receive,s),e},generateKey:()=>(0,s.randomBytes)(32)}},34654:()=>{},34149:()=>{},89780:()=>{},99926:()=>{},90124:()=>{},71220:()=>{},38854:()=>{},37115:()=>{},60522:()=>{},70877:()=>{},87862:()=>{},77356:()=>{},22238:()=>{}}]);